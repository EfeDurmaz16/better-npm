{"version":3,"sources":["../src/utils/execFileNoThrow.ts","../src/doctor/score.ts","../src/cli/parser.ts","../src/cli/output.ts","../src/cli/commands/index.ts","../src/index.ts","../src/adapters/base.ts","../src/adapters/npm.ts","../src/adapters/pnpm.ts","../src/adapters/yarn-classic.ts","../src/adapters/yarn-berry.ts","../src/adapters/index.ts","../src/observability/logger.ts","../src/utils/spawn.ts","../src/fs/index.ts","../src/cli/commands/install.ts","../src/cli/commands/analyze.ts","../src/analyzer/graph.ts","../src/fs/scanner.ts","../src/fs/hardlinks.ts","../src/fs/size.ts","../src/analyzer/duplicates.ts","../src/analyzer/depth.ts","../src/analyzer/deprecation.ts","../src/cache/manager.ts","../src/utils/paths.ts","../src/cache/gc.ts","../src/cli/commands/cache.ts","../src/cli/commands/doctor.ts","../src/doctor/engine.ts","../src/doctor/checks/duplicates.ts","../src/doctor/checks/deprecated.ts","../src/doctor/checks/depth.ts","../src/doctor/checks/size.ts","../src/doctor/checks/index.ts","../src/web/server.ts","../src/cli/commands/serve.ts","../src/cli.ts"],"sourcesContent":["import { execFile } from 'node:child_process';\nimport { promisify } from 'node:util';\n\nconst execFileAsync = promisify(execFile);\n\nexport interface ExecFileResult {\n  stdout: string;\n  stderr: string;\n  exitCode: number;\n}\n\n/**\n * Safely execute a command using execFile (no shell injection).\n * Returns result with stdout, stderr, and exitCode instead of throwing.\n */\nexport async function execFileNoThrow(\n  command: string,\n  args: string[] = [],\n  options: { cwd?: string; encoding?: BufferEncoding } = {}\n): Promise<ExecFileResult> {\n  try {\n    const { stdout, stderr } = await execFileAsync(command, args, {\n      ...options,\n      encoding: options.encoding ?? 'utf-8',\n    });\n    return {\n      stdout: stdout as string,\n      stderr: stderr as string,\n      exitCode: 0,\n    };\n  } catch (error: any) {\n    return {\n      stdout: error.stdout ?? '',\n      stderr: error.stderr ?? error.message ?? '',\n      exitCode: error.code ?? 1,\n    };\n  }\n}\n","import { Finding } from './engine.js';\n\n/**\n * Calculate health score from findings\n * Score = 100 - sum(finding.weight), capped at [0, 100]\n */\nexport function calculateScore(findings: Finding[]): number {\n  const totalDeductions = findings.reduce((sum, f) => sum + f.weight, 0);\n  return Math.max(0, Math.min(100, 100 - totalDeductions));\n}\n","export interface ParsedArgs {\n  command: string | undefined;\n  positionals: string[];\n  flags: Record<string, string | boolean | string[]>;\n}\n\nexport function parseArgs(args: string[]): ParsedArgs {\n  const result: ParsedArgs = {\n    command: undefined,\n    positionals: [],\n    flags: {},\n  };\n\n  let i = 0;\n  let commandFound = false;\n\n  // Helper to check if a string looks like a flag (not a negative number)\n  const isFlag = (str: string): boolean => {\n    if (!str.startsWith('-')) return false;\n    // Single dash is not a flag\n    if (str === '-') return false;\n    // Check if it's a negative number: starts with - followed by digits (optionally with decimal)\n    const negativeNumberPattern = /^-\\d+(\\.\\d+)?$/;\n    return !negativeNumberPattern.test(str);\n  };\n\n  while (i < args.length) {\n    const arg = args[i];\n    if (!arg) {\n      i++;\n      continue;\n    }\n\n    if (arg.startsWith('--')) {\n      // Long flag: --flag or --flag=value\n      const equalIndex = arg.indexOf('=');\n      if (equalIndex !== -1) {\n        const key = arg.slice(2, equalIndex);\n        const value = arg.slice(equalIndex + 1);\n        result.flags[key] = value;\n      } else {\n        const key = arg.slice(2);\n        const nextArg = args[i + 1];\n        // Check if next arg is a value (not a flag)\n        if (i + 1 < args.length && nextArg && !isFlag(nextArg)) {\n          result.flags[key] = nextArg;\n          i++; // Skip next arg as it's the value\n        } else {\n          result.flags[key] = true;\n        }\n      }\n    } else if (arg.startsWith('-') && arg.length > 1 && arg !== '-') {\n      // Short flag: -f or -f value\n      const key = arg.slice(1);\n\n      // Handle multiple short flags like -abc as -a -b -c\n      if (key.length > 1) {\n        for (const char of key) {\n          result.flags[char] = true;\n        }\n      } else {\n        const nextArg = args[i + 1];\n        // Single short flag, check for value\n        if (i + 1 < args.length && nextArg && !isFlag(nextArg)) {\n          result.flags[key] = nextArg;\n          i++; // Skip next arg as it's the value\n        } else {\n          result.flags[key] = true;\n        }\n      }\n    } else {\n      // Positional argument\n      if (!commandFound) {\n        result.command = arg;\n        commandFound = true;\n      } else {\n        result.positionals.push(arg);\n      }\n    }\n\n    i++;\n  }\n\n  return result;\n}\n","export interface OutputOptions {\n  json: boolean;\n  color: boolean;\n}\n\nexport class Output {\n  constructor(private options: OutputOptions) {}\n\n  log(message: string): void {\n    if (!this.options.json) {\n      console.log(message);\n    }\n  }\n\n  json(data: unknown): void {\n    console.log(JSON.stringify(data, null, 2));\n  }\n\n  error(message: string): void {\n    if (this.options.json) {\n      this.json({ error: message });\n    } else {\n      console.error(this.formatError(message));\n    }\n  }\n\n  success(message: string): void {\n    if (!this.options.json) {\n      const checkmark = this.options.color ? '\\u2713' : '✓';\n      console.log(`${checkmark} ${message}`);\n    }\n  }\n\n  warn(message: string): void {\n    if (!this.options.json) {\n      const warning = this.options.color ? '\\u26A0' : '⚠';\n      console.warn(`${warning} ${message}`);\n    }\n  }\n\n  table(headers: string[], rows: string[][]): string {\n    if (rows.length === 0) {\n      return '';\n    }\n\n    // Calculate column widths\n    const colWidths = headers.map((header, i) => {\n      const maxRowWidth = Math.max(...rows.map(row => (row[i] || '').length));\n      return Math.max(header.length, maxRowWidth);\n    });\n\n    // Build header\n    const headerRow = headers\n      .map((header, i) => {\n        const width = colWidths[i];\n        return width !== undefined ? header.padEnd(width) : header;\n      })\n      .join('  ');\n\n    const separator = colWidths.map(width => '-'.repeat(width || 0)).join('  ');\n\n    // Build rows\n    const dataRows = rows.map(row =>\n      row.map((cell, i) => {\n        const width = colWidths[i];\n        return width !== undefined ? (cell || '').padEnd(width) : (cell || '');\n      }).join('  ')\n    );\n\n    return [headerRow, separator, ...dataRows].join('\\n');\n  }\n\n  private formatError(message: string): string {\n    if (this.options.color) {\n      return `\\x1b[31mError:\\x1b[0m ${message}`;\n    }\n    return `Error: ${message}`;\n  }\n}\n\nexport function createOutput(options: Partial<OutputOptions> = {}): Output {\n  const defaults: OutputOptions = {\n    json: false,\n    color: process.stdout.isTTY !== false,\n  };\n\n  return new Output({ ...defaults, ...options });\n}\n","import type { ParsedArgs } from '../parser.js';\nimport type { Output } from '../output.js';\n\nexport interface BetterConfig {\n  [key: string]: unknown;\n}\n\nexport interface CommandContext {\n  args: ParsedArgs;\n  output: Output;\n  config: BetterConfig;\n}\n\nexport interface Command {\n  name: string;\n  description: string;\n  run(ctx: CommandContext): Promise<number>;\n}\n\nexport const commands: Map<string, Command> = new Map();\n\nexport function registerCommand(cmd: Command): void {\n  commands.set(cmd.name, cmd);\n}\n\nexport function getCommand(name: string): Command | undefined {\n  return commands.get(name);\n}\n","export const VERSION = '0.1.0';\n","export interface ExecResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n  duration: number; // ms\n}\n\nexport interface InstallOptions {\n  frozen?: boolean;\n  production?: boolean;\n  args?: string[];\n}\n\nexport abstract class PackageManagerAdapter {\n  abstract readonly name: string;\n  abstract readonly lockfile: string;\n\n  protected version: string = '';\n  protected cwd: string;\n\n  constructor(cwd: string) {\n    this.cwd = cwd;\n  }\n\n  // Check if this adapter applies to the current directory\n  abstract detect(): Promise<boolean>;\n\n  // Get the version of this package manager\n  abstract getVersion(): Promise<string>;\n\n  // Build the install command\n  abstract getInstallCommand(options: InstallOptions): string[];\n\n  // Get the cache directory for this PM\n  abstract getCachePath(): string;\n\n  // Run the install command\n  async install(options: InstallOptions = {}): Promise<ExecResult> {\n    const cmd = this.getInstallCommand(options);\n    return this.exec(cmd);\n  }\n\n  // Execute a command\n  protected async exec(args: string[]): Promise<ExecResult> {\n    const { spawn } = await import('node:child_process');\n    const start = performance.now();\n\n    return new Promise((resolve) => {\n      const proc = spawn(args[0]!, args.slice(1), {\n        cwd: this.cwd,\n        stdio: ['inherit', 'pipe', 'pipe'],\n        shell: process.platform === 'win32',\n      });\n\n      let stdout = '';\n      let stderr = '';\n\n      proc.stdout?.on('data', (data: Buffer) => {\n        stdout += data.toString();\n      });\n\n      proc.stderr?.on('data', (data: Buffer) => {\n        stderr += data.toString();\n      });\n\n      proc.on('close', (code) => {\n        resolve({\n          exitCode: code ?? 1,\n          stdout,\n          stderr,\n          duration: Math.round(performance.now() - start),\n        });\n      });\n\n      proc.on('error', (err) => {\n        resolve({\n          exitCode: 1,\n          stdout,\n          stderr: err.message,\n          duration: Math.round(performance.now() - start),\n        });\n      });\n    });\n  }\n\n  // Check if a command exists\n  protected async commandExists(cmd: string): Promise<boolean> {\n    const { execFileNoThrow } = await import('../utils/execFileNoThrow.js');\n    const command = process.platform === 'win32' ? 'where' : 'which';\n    const result = await execFileNoThrow(command, [cmd]);\n    return result.exitCode === 0;\n  }\n}\n","import { PackageManagerAdapter, InstallOptions } from './base.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as os from 'node:os';\n\nexport class NpmAdapter extends PackageManagerAdapter {\n  readonly name = 'npm';\n  readonly lockfile = 'package-lock.json';\n\n  async detect(): Promise<boolean> {\n    // Check for package-lock.json or npm-shrinkwrap.json\n    const hasPackageLock = fs.existsSync(path.join(this.cwd, 'package-lock.json'));\n    const hasShrinkwrap = fs.existsSync(path.join(this.cwd, 'npm-shrinkwrap.json'));\n\n    if (!hasPackageLock && !hasShrinkwrap) {\n      return false;\n    }\n\n    // Verify npm is installed\n    return this.commandExists('npm');\n  }\n\n  async getVersion(): Promise<string> {\n    if (this.version) return this.version;\n\n    const { execFileNoThrow } = await import('../utils/execFileNoThrow.js');\n    const result = await execFileNoThrow('npm', ['--version']);\n    this.version = result.exitCode === 0 ? result.stdout.trim() : 'unknown';\n    return this.version;\n  }\n\n  getInstallCommand(options: InstallOptions): string[] {\n    const cmd = ['npm'];\n\n    if (options.frozen) {\n      cmd.push('ci');\n    } else {\n      cmd.push('install');\n    }\n\n    if (options.production) {\n      cmd.push('--omit=dev');\n    }\n\n    if (options.args) {\n      cmd.push(...options.args);\n    }\n\n    return cmd;\n  }\n\n  getCachePath(): string {\n    // npm cache is at ~/.npm\n    if (process.env['npm_config_cache']) {\n      return process.env['npm_config_cache'];\n    }\n    return path.join(os.homedir(), '.npm');\n  }\n}\n","import { PackageManagerAdapter, InstallOptions } from './base.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as os from 'node:os';\n\nexport class PnpmAdapter extends PackageManagerAdapter {\n  readonly name = 'pnpm';\n  readonly lockfile = 'pnpm-lock.yaml';\n\n  async detect(): Promise<boolean> {\n    const hasLockfile = fs.existsSync(path.join(this.cwd, 'pnpm-lock.yaml'));\n    if (!hasLockfile) return false;\n    return this.commandExists('pnpm');\n  }\n\n  async getVersion(): Promise<string> {\n    if (this.version) return this.version;\n\n    const { execFileNoThrow } = await import('../utils/execFileNoThrow.js');\n    const result = await execFileNoThrow('pnpm', ['--version']);\n    this.version = result.exitCode === 0 ? result.stdout.trim() : 'unknown';\n    return this.version;\n  }\n\n  getInstallCommand(options: InstallOptions): string[] {\n    const cmd = ['pnpm', 'install'];\n\n    if (options.frozen) {\n      cmd.push('--frozen-lockfile');\n    }\n\n    if (options.production) {\n      cmd.push('--prod');\n    }\n\n    if (options.args) {\n      cmd.push(...options.args);\n    }\n\n    return cmd;\n  }\n\n  getCachePath(): string {\n    // pnpm store directory\n    if (process.env['PNPM_HOME']) {\n      return path.join(process.env['PNPM_HOME'], 'store');\n    }\n\n    // Default locations\n    const platform = os.platform();\n    if (platform === 'win32') {\n      return path.join(process.env['LOCALAPPDATA'] ?? os.homedir(), 'pnpm', 'store');\n    }\n    return path.join(os.homedir(), '.local', 'share', 'pnpm', 'store');\n  }\n}\n","import { PackageManagerAdapter, InstallOptions } from './base.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as os from 'node:os';\n\nexport class YarnClassicAdapter extends PackageManagerAdapter {\n  readonly name = 'yarn-classic';\n  readonly lockfile = 'yarn.lock';\n\n  async detect(): Promise<boolean> {\n    const hasLockfile = fs.existsSync(path.join(this.cwd, 'yarn.lock'));\n    if (!hasLockfile) return false;\n\n    // Check it's NOT Berry (no .yarnrc.yml)\n    const hasYarnrcYml = fs.existsSync(path.join(this.cwd, '.yarnrc.yml'));\n    if (hasYarnrcYml) return false;\n\n    // Check yarn version is 1.x\n    const version = await this.getVersion();\n    return version.startsWith('1.');\n  }\n\n  async getVersion(): Promise<string> {\n    if (this.version) return this.version;\n\n    const { execFileNoThrow } = await import('../utils/execFileNoThrow.js');\n    const result = await execFileNoThrow('yarn', ['--version']);\n    this.version = result.exitCode === 0 ? result.stdout.trim() : 'unknown';\n    return this.version;\n  }\n\n  getInstallCommand(options: InstallOptions): string[] {\n    const cmd = ['yarn'];\n\n    if (options.frozen) {\n      cmd.push('install', '--frozen-lockfile');\n    } else {\n      cmd.push('install');\n    }\n\n    if (options.production) {\n      cmd.push('--production');\n    }\n\n    if (options.args) {\n      cmd.push(...options.args);\n    }\n\n    return cmd;\n  }\n\n  getCachePath(): string {\n    if (process.env['YARN_CACHE_FOLDER']) {\n      return process.env['YARN_CACHE_FOLDER'];\n    }\n\n    // Default yarn cache location\n    const platform = os.platform();\n    if (platform === 'darwin') {\n      return path.join(os.homedir(), 'Library', 'Caches', 'Yarn');\n    }\n    if (platform === 'win32') {\n      return path.join(process.env['LOCALAPPDATA'] ?? os.homedir(), 'Yarn', 'Cache');\n    }\n    return path.join(os.homedir(), '.cache', 'yarn');\n  }\n}\n","import { PackageManagerAdapter, InstallOptions } from './base.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport * as os from 'node:os';\n\nexport class YarnBerryAdapter extends PackageManagerAdapter {\n  readonly name = 'yarn-berry';\n  readonly lockfile = 'yarn.lock';\n\n  async detect(): Promise<boolean> {\n    const hasLockfile = fs.existsSync(path.join(this.cwd, 'yarn.lock'));\n    if (!hasLockfile) return false;\n\n    // Check for .yarnrc.yml (Berry indicator)\n    const hasYarnrcYml = fs.existsSync(path.join(this.cwd, '.yarnrc.yml'));\n    if (hasYarnrcYml) return true;\n\n    // Or check version is 2+\n    const version = await this.getVersion();\n    const major = parseInt(version.split('.')[0] ?? '0', 10);\n    return major >= 2;\n  }\n\n  async getVersion(): Promise<string> {\n    if (this.version) return this.version;\n\n    const { execFileNoThrow } = await import('../utils/execFileNoThrow.js');\n    const result = await execFileNoThrow('yarn', ['--version']);\n    this.version = result.exitCode === 0 ? result.stdout.trim() : 'unknown';\n    return this.version;\n  }\n\n  getInstallCommand(options: InstallOptions): string[] {\n    const cmd = ['yarn'];\n\n    if (options.frozen) {\n      cmd.push('install', '--immutable');\n    } else {\n      cmd.push('install');\n    }\n\n    // Note: Berry doesn't have a --production flag in the same way\n    // It uses different mechanisms (plugins, etc.)\n\n    if (options.args) {\n      cmd.push(...options.args);\n    }\n\n    return cmd;\n  }\n\n  getCachePath(): string {\n    // Berry uses cacheFolder in .yarnrc.yml, or global cache\n    // Try to read from .yarnrc.yml\n    const yarnrcPath = path.join(this.cwd, '.yarnrc.yml');\n    if (fs.existsSync(yarnrcPath)) {\n      const content = fs.readFileSync(yarnrcPath, 'utf-8');\n      const match = content.match(/cacheFolder:\\s*(.+)/);\n      if (match?.[1]) {\n        return match[1].trim();\n      }\n    }\n\n    // Default global cache\n    if (process.env['YARN_CACHE_FOLDER']) {\n      return process.env['YARN_CACHE_FOLDER'];\n    }\n\n    const platform = os.platform();\n    if (platform === 'darwin') {\n      return path.join(os.homedir(), 'Library', 'Caches', 'Yarn');\n    }\n    if (platform === 'win32') {\n      return path.join(process.env['LOCALAPPDATA'] ?? os.homedir(), 'Yarn', 'Cache');\n    }\n    return path.join(os.homedir(), '.cache', 'yarn');\n  }\n}\n","import { PackageManagerAdapter } from './base.js';\nimport { NpmAdapter } from './npm.js';\nimport { PnpmAdapter } from './pnpm.js';\nimport { YarnClassicAdapter } from './yarn-classic.js';\nimport { YarnBerryAdapter } from './yarn-berry.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport { PackageManagerAdapter, ExecResult, InstallOptions } from './base.js';\nexport { NpmAdapter } from './npm.js';\nexport { PnpmAdapter } from './pnpm.js';\nexport { YarnClassicAdapter } from './yarn-classic.js';\nexport { YarnBerryAdapter } from './yarn-berry.js';\n\nexport type PackageManagerName = 'npm' | 'pnpm' | 'yarn-classic' | 'yarn-berry';\n\n// Detect and return the appropriate adapter\nexport async function detectPackageManager(cwd: string = process.cwd()): Promise<PackageManagerAdapter> {\n  // Check package.json#packageManager first\n  const pkgPath = path.join(cwd, 'package.json');\n  if (fs.existsSync(pkgPath)) {\n    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));\n    if (pkg.packageManager) {\n      const pm = parsePackageManager(pkg.packageManager);\n      if (pm) {\n        const adapter = createAdapter(pm, cwd);\n        if (await adapter.detect()) {\n          return adapter;\n        }\n      }\n    }\n  }\n\n  // Try detection in order of specificity\n  // pnpm first (has unique lockfile)\n  const pnpm = new PnpmAdapter(cwd);\n  if (await pnpm.detect()) return pnpm;\n\n  // Yarn Berry before Classic (has .yarnrc.yml)\n  const yarnBerry = new YarnBerryAdapter(cwd);\n  if (await yarnBerry.detect()) return yarnBerry;\n\n  // Yarn Classic\n  const yarnClassic = new YarnClassicAdapter(cwd);\n  if (await yarnClassic.detect()) return yarnClassic;\n\n  // npm last (most common fallback)\n  const npm = new NpmAdapter(cwd);\n  if (await npm.detect()) return npm;\n\n  // Default to npm if nothing detected\n  return npm;\n}\n\nfunction parsePackageManager(value: string): PackageManagerName | null {\n  // Format: \"npm@9.0.0\" or \"pnpm@8.0.0\" or \"yarn@3.0.0\"\n  const match = value.match(/^(npm|pnpm|yarn)@/);\n  if (!match) return null;\n\n  const name = match[1];\n  if (name === 'yarn') {\n    // Need to determine Classic vs Berry from version\n    const versionMatch = value.match(/@(\\d+)/);\n    const major = parseInt(versionMatch?.[1] ?? '1', 10);\n    return major >= 2 ? 'yarn-berry' : 'yarn-classic';\n  }\n\n  return name as PackageManagerName;\n}\n\nfunction createAdapter(name: PackageManagerName, cwd: string): PackageManagerAdapter {\n  switch (name) {\n    case 'npm':\n      return new NpmAdapter(cwd);\n    case 'pnpm':\n      return new PnpmAdapter(cwd);\n    case 'yarn-classic':\n      return new YarnClassicAdapter(cwd);\n    case 'yarn-berry':\n      return new YarnBerryAdapter(cwd);\n  }\n}\n","export type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'silent';\n\nexport interface LogEntry {\n  ts: string; // ISO timestamp\n  level: LogLevel;\n  msg: string;\n  [key: string]: unknown; // Additional context\n}\n\nexport interface LoggerOptions {\n  level: LogLevel;\n  json: boolean; // If false, use human-readable format\n}\n\nconst LEVEL_PRIORITY: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3,\n  silent: 4,\n};\n\nexport class Logger {\n  private level: LogLevel;\n  private json: boolean;\n\n  constructor(options: LoggerOptions) {\n    this.level = options.level;\n    this.json = options.json;\n  }\n\n  private shouldLog(level: LogLevel): boolean {\n    return LEVEL_PRIORITY[level] >= LEVEL_PRIORITY[this.level];\n  }\n\n  private formatMessage(level: LogLevel, msg: string, context?: Record<string, unknown>): string {\n    const entry: LogEntry = {\n      ts: new Date().toISOString(),\n      level,\n      msg,\n      ...context,\n    };\n\n    if (this.json) {\n      return JSON.stringify(entry);\n    }\n\n    // Human-readable format\n    const levelStr = level.toUpperCase().padEnd(5);\n    const contextStr = context ? ` ${JSON.stringify(context)}` : '';\n    return `[${entry.ts}] ${levelStr} ${msg}${contextStr}`;\n  }\n\n  private write(level: LogLevel, msg: string, context?: Record<string, unknown>): void {\n    if (!this.shouldLog(level)) return;\n    const formatted = this.formatMessage(level, msg, context);\n    process.stderr.write(formatted + '\\n');\n  }\n\n  debug(msg: string, context?: Record<string, unknown>): void {\n    this.write('debug', msg, context);\n  }\n\n  info(msg: string, context?: Record<string, unknown>): void {\n    this.write('info', msg, context);\n  }\n\n  warn(msg: string, context?: Record<string, unknown>): void {\n    this.write('warn', msg, context);\n  }\n\n  error(msg: string, context?: Record<string, unknown>): void {\n    this.write('error', msg, context);\n  }\n\n  setLevel(level: LogLevel): void {\n    this.level = level;\n  }\n\n  setJson(json: boolean): void {\n    this.json = json;\n  }\n\n  // Create a child logger with additional context\n  child(context: Record<string, unknown>): ChildLogger {\n    return new ChildLogger(this, context);\n  }\n\n  // Time an operation\n  time(label: string): () => void {\n    const start = performance.now();\n    return () => {\n      const duration = performance.now() - start;\n      this.debug(`${label} completed`, { durationMs: Math.round(duration) });\n    };\n  }\n}\n\nclass ChildLogger {\n  constructor(\n    private parent: Logger,\n    private context: Record<string, unknown>\n  ) {}\n\n  debug(msg: string, context?: Record<string, unknown>): void {\n    this.parent.debug(msg, { ...this.context, ...context });\n  }\n\n  info(msg: string, context?: Record<string, unknown>): void {\n    this.parent.info(msg, { ...this.context, ...context });\n  }\n\n  warn(msg: string, context?: Record<string, unknown>): void {\n    this.parent.warn(msg, { ...this.context, ...context });\n  }\n\n  error(msg: string, context?: Record<string, unknown>): void {\n    this.parent.error(msg, { ...this.context, ...context });\n  }\n}\n\n// Global logger instance\nlet globalLogger: Logger | null = null;\n\nexport function createLogger(options: LoggerOptions): Logger {\n  globalLogger = new Logger(options);\n  return globalLogger;\n}\n\nexport function getLogger(): Logger {\n  if (!globalLogger) {\n    // Default logger for early use\n    globalLogger = new Logger({ level: 'info', json: false });\n  }\n  return globalLogger;\n}\n\n// Convenience exports\nexport const logger = {\n  debug: (msg: string, context?: Record<string, unknown>) => getLogger().debug(msg, context),\n  info: (msg: string, context?: Record<string, unknown>) => getLogger().info(msg, context),\n  warn: (msg: string, context?: Record<string, unknown>) => getLogger().warn(msg, context),\n  error: (msg: string, context?: Record<string, unknown>) => getLogger().error(msg, context),\n};\n","import { spawn, type SpawnOptions as NodeSpawnOptions } from 'node:child_process';\n\nexport interface ExecResult {\n  exitCode: number;\n  stdout: string;\n  stderr: string;\n  duration: number;\n}\n\nexport interface SpawnOptions extends NodeSpawnOptions {\n  inheritStdio?: boolean;\n}\n\n/**\n * Spawn a process and capture its output along with timing metrics.\n *\n * @param cmd - Command to execute\n * @param args - Arguments to pass to the command\n * @param options - Spawn options\n * @returns Promise with exit code, stdout, stderr, and duration\n */\nexport function spawnWithOutput(\n  cmd: string,\n  args: string[],\n  options: SpawnOptions = {}\n): Promise<ExecResult> {\n  const start = performance.now();\n  const { inheritStdio, ...spawnOpts } = options;\n\n  // Default stdio configuration\n  const stdio = inheritStdio ? 'inherit' : ['inherit', 'pipe', 'pipe'];\n\n  return new Promise((resolve) => {\n    const proc = spawn(cmd, args, {\n      ...spawnOpts,\n      stdio: stdio as NodeSpawnOptions['stdio'],\n      shell: process.platform === 'win32',\n    });\n\n    let stdout = '';\n    let stderr = '';\n\n    // Only collect output if not inheriting stdio\n    if (!inheritStdio) {\n      proc.stdout?.on('data', (data: Buffer) => {\n        stdout += data.toString();\n        // Also write to stdout for real-time feedback\n        process.stdout.write(data);\n      });\n\n      proc.stderr?.on('data', (data: Buffer) => {\n        stderr += data.toString();\n        // Also write to stderr for real-time feedback\n        process.stderr.write(data);\n      });\n    }\n\n    proc.on('close', (code) => {\n      const duration = Math.round(performance.now() - start);\n      resolve({\n        exitCode: code ?? 1,\n        stdout,\n        stderr,\n        duration,\n      });\n    });\n\n    proc.on('error', (err) => {\n      const duration = Math.round(performance.now() - start);\n      resolve({\n        exitCode: 1,\n        stdout,\n        stderr: err.message,\n        duration,\n      });\n    });\n  });\n}\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nexport interface DirectoryEntry {\n  name: string;\n  path: string;\n  isDirectory: boolean;\n}\n\nexport interface SizeResult {\n  logicalSize: number;\n  physicalSize: number;\n  fileCount: number;\n}\n\n/**\n * Scans a directory and returns all entries (non-recursive by default)\n */\nexport async function scanDirectory(dirPath: string, recursive = false): Promise<DirectoryEntry[]> {\n  try {\n    if (!fs.existsSync(dirPath)) {\n      return [];\n    }\n\n    const entries: DirectoryEntry[] = [];\n    const items = await fs.promises.readdir(dirPath, { withFileTypes: true });\n\n    for (const item of items) {\n      const fullPath = path.join(dirPath, item.name);\n      entries.push({\n        name: item.name,\n        path: fullPath,\n        isDirectory: item.isDirectory(),\n      });\n\n      if (recursive && item.isDirectory()) {\n        const subEntries = await scanDirectory(fullPath, true);\n        entries.push(...subEntries);\n      }\n    }\n\n    return entries;\n  } catch (error) {\n    // Directory doesn't exist or is inaccessible\n    return [];\n  }\n}\n\n/**\n * Counts packages in node_modules by counting directories\n */\nexport async function countPackages(nodeModulesPath: string): Promise<number> {\n  try {\n    if (!fs.existsSync(nodeModulesPath)) {\n      return 0;\n    }\n\n    let count = 0;\n    const entries = await fs.promises.readdir(nodeModulesPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.isDirectory()) {\n        if (entry.name.startsWith('@')) {\n          // Scoped package - count subdirectories\n          const scopePath = path.join(nodeModulesPath, entry.name);\n          const scopedPackages = await fs.promises.readdir(scopePath, { withFileTypes: true });\n          count += scopedPackages.filter(e => e.isDirectory()).length;\n        } else if (entry.name !== '.bin' && entry.name !== '.cache') {\n          count++;\n        }\n      }\n    }\n\n    return count;\n  } catch (error) {\n    return 0;\n  }\n}\n\n/**\n * Calculates both logical and physical size of a directory\n * - Logical size: sum of all file sizes (counts hardlinks multiple times)\n * - Physical size: sum of unique inodes (counts hardlinks once)\n */\nexport async function calculateSize(dirPath: string): Promise<SizeResult> {\n  const hardlinkTracker = new Map<string, boolean>();\n  let logicalSize = 0;\n  let physicalSize = 0;\n  let fileCount = 0;\n\n  async function scanDir(dir: string): Promise<void> {\n    try {\n      if (!fs.existsSync(dir)) {\n        return;\n      }\n\n      const entries = await fs.promises.readdir(dir, { withFileTypes: true });\n\n      for (const entry of entries) {\n        const fullPath = path.join(dir, entry.name);\n\n        if (entry.isDirectory()) {\n          await scanDir(fullPath);\n        } else if (entry.isFile() || entry.isSymbolicLink()) {\n          try {\n            const stats = await fs.promises.stat(fullPath);\n            fileCount++;\n            logicalSize += stats.size;\n\n            // Track hardlinks via inode+dev\n            const key = `${stats.dev}:${stats.ino}`;\n            if (!hardlinkTracker.has(key)) {\n              hardlinkTracker.set(key, true);\n              physicalSize += stats.size;\n            }\n          } catch {\n            // Skip files we can't stat\n          }\n        }\n      }\n    } catch (error) {\n      // Skip directories we can't read\n    }\n  }\n\n  await scanDir(dirPath);\n\n  return {\n    logicalSize,\n    physicalSize,\n    fileCount,\n  };\n}\n\n/**\n * Counts packages from a lockfile\n */\nexport function countLockfilePackages(lockfilePath: string): number {\n  try {\n    if (!fs.existsSync(lockfilePath)) {\n      return 0;\n    }\n\n    const content = fs.readFileSync(lockfilePath, 'utf-8');\n    const filename = path.basename(lockfilePath);\n\n    if (filename === 'package-lock.json') {\n      // npm lockfile - count packages in \"packages\" object (v2+) or \"dependencies\" (v1)\n      const lockfile = JSON.parse(content);\n      if (lockfile.packages) {\n        // v2+ format: packages object, exclude the root \"\"\n        return Object.keys(lockfile.packages).filter(key => key !== '').length;\n      } else if (lockfile.dependencies) {\n        // v1 format: count dependencies recursively\n        return countDependenciesRecursive(lockfile.dependencies);\n      }\n      return 0;\n    } else if (filename === 'pnpm-lock.yaml') {\n      // pnpm lockfile - count entries in packages section\n      const packagesMatch = content.match(/^packages:/m);\n      if (!packagesMatch) return 0;\n\n      // Count lines that start with two spaces followed by a package reference\n      // These are in the format: \"  '@scope/package@version':\" or \"  /package@version:\"\n      const packageLines = content.split('\\n').filter(line =>\n        /^  ['\"]?[@/]/.test(line) && line.includes(':')\n      );\n      return packageLines.length;\n    } else if (filename === 'yarn.lock') {\n      // yarn lockfile - count package entries (lines ending with :)\n      // Format: \"package@version:\", \"package@npm:version:\", etc.\n      const entries = content.split('\\n').filter(line =>\n        /^[^#\\s].*:$/.test(line.trim()) && !line.includes('\"')\n      );\n      return entries.length;\n    }\n\n    return 0;\n  } catch (error) {\n    return 0;\n  }\n}\n\nfunction countDependenciesRecursive(deps: Record<string, any>): number {\n  let count = Object.keys(deps).length;\n  for (const dep of Object.values(deps)) {\n    if (dep.dependencies) {\n      count += countDependenciesRecursive(dep.dependencies);\n    }\n  }\n  return count;\n}\n\n/**\n * Formats bytes to human-readable string\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n}\n","import type { Command, CommandContext } from './index.js';\nimport { registerCommand } from './index.js';\nimport { detectPackageManager } from '../../adapters/index.js';\nimport { getLogger } from '../../observability/logger.js';\nimport { spawnWithOutput } from '../../utils/spawn.js';\nimport { countPackages, calculateSize, countLockfilePackages } from '../../fs/index.js';\nimport * as path from 'node:path';\n\ninterface InstallMetrics {\n  duration: number;        // milliseconds\n  packagesInstalled: number;\n  packagesBefore: number;\n  packagesAfter: number;\n  sizeAdded: number;       // bytes\n  sizeBefore: number;\n  sizeAfter: number;\n  cacheHits: 0;           // placeholder for future\n  cacheMisses: 0;         // placeholder for future\n}\n\nfunction formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n  const k = 1024;\n  const sizes = ['B', 'KB', 'MB', 'GB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;\n}\n\nconst installCommand: Command = {\n  name: 'install',\n  description: 'Install dependencies with enhanced features',\n  async run(ctx: CommandContext): Promise<number> {\n    const logger = getLogger();\n    const cwd = process.cwd();\n\n    // Parse install-specific flags\n    const dryRun = ctx.args.flags['dry-run'] === true;\n    const frozen = ctx.args.flags['frozen'] === true;\n    const production = ctx.args.flags['production'] === true;\n    const jsonOutput = ctx.args.flags['json'] === true;\n\n    try {\n      // Detect package manager\n      logger.debug('Detecting package manager', { cwd });\n      const adapter = await detectPackageManager(cwd);\n      logger.info('Detected package manager', { pm: adapter.name });\n\n      // Build install command\n      const installOptions = {\n        frozen,\n        production,\n        args: ctx.args.positionals, // Additional packages to install\n      };\n\n      const commandArgs = adapter.getInstallCommand(installOptions);\n      logger.debug('Install command', { command: commandArgs.join(' ') });\n\n      if (dryRun) {\n        // Get lockfile path and count packages\n        const lockfilePath = path.join(cwd, adapter.lockfile);\n        const estimatedPackages = countLockfilePackages(lockfilePath);\n\n        const result = {\n          dryRun: true,\n          command: commandArgs.join(' '),\n          packageManager: adapter.name,\n          estimatedPackages,\n          wouldExecute: commandArgs,\n          lockfileExists: estimatedPackages > 0,\n        };\n\n        if (jsonOutput) {\n          console.log(JSON.stringify(result, null, 2));\n        } else {\n          ctx.output.log(`[Dry run] Would execute: ${result.command}`);\n          if (estimatedPackages > 0) {\n            ctx.output.log(`Estimated packages: ${estimatedPackages}`);\n          } else {\n            ctx.output.log('No lockfile found or lockfile is empty');\n          }\n        }\n\n        return 0;\n      }\n\n      // Execute install\n      ctx.output.log(`Installing with ${adapter.name}...`);\n      const startTime = performance.now();\n\n      const result = await spawnWithOutput(commandArgs[0]!, commandArgs.slice(1), {\n        cwd,\n        inheritStdio: true,\n      });\n\n      const durationSec = (result.duration / 1000).toFixed(2);\n\n      // Report results\n      if (result.exitCode === 0) {\n        ctx.output.success(`Installation completed in ${durationSec}s`);\n        logger.info('Install completed', {\n          pm: adapter.name,\n          durationMs: result.duration,\n          exitCode: result.exitCode,\n        });\n      } else {\n        ctx.output.error(`Installation failed (exit code ${result.exitCode})`);\n        logger.error('Install failed', {\n          pm: adapter.name,\n          durationMs: result.duration,\n          exitCode: result.exitCode,\n        });\n      }\n\n      return result.exitCode;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      ctx.output.error(`Install failed: ${errorMessage}`);\n      logger.error('Install error', { error: errorMessage });\n      return 1;\n    }\n  },\n};\n\nregisterCommand(installCommand);\n\nexport default installCommand;\n","import * as path from 'node:path';\nimport type { Command, CommandContext } from './index.js';\nimport { registerCommand } from './index.js';\nimport { buildDependencyGraph } from '../../analyzer/graph.js';\nimport { detectDuplicates } from '../../analyzer/duplicates.js';\nimport { analyzeDepth } from '../../analyzer/depth.js';\nimport { detectDeprecated } from '../../analyzer/deprecation.js';\nimport { formatBytes } from '../../fs/size.js';\n\nconst analyzeCommand: Command = {\n  name: 'analyze',\n  description: 'Analyze dependencies for issues and optimizations',\n  async run(ctx: CommandContext): Promise<number> {\n    const cwd = process.cwd();\n    const nodeModulesPath = path.join(cwd, 'node_modules');\n\n    // Parse flags\n    const jsonOutput = ctx.args.flags['json'] === true;\n    const duplicatesOnly = ctx.args.flags['duplicates'] === true;\n    const depthOnly = ctx.args.flags['depth'] === true;\n    const deprecatedOnly = ctx.args.flags['deprecated'] === true;\n\n    try {\n      // Build dependency graph\n      const graph = buildDependencyGraph(nodeModulesPath);\n\n      // Run analyses based on flags\n      const shouldRunAll = !duplicatesOnly && !depthOnly && !deprecatedOnly;\n\n      let duplicates;\n      let depth;\n      let deprecated;\n\n      if (shouldRunAll || duplicatesOnly) {\n        duplicates = detectDuplicates(graph);\n      }\n\n      if (shouldRunAll || depthOnly) {\n        depth = analyzeDepth(graph);\n      }\n\n      if (shouldRunAll || deprecatedOnly) {\n        deprecated = detectDeprecated(graph, cwd);\n      }\n\n      // Calculate total disk size\n      let totalSize = 0;\n      for (const node of graph.packages.values()) {\n        totalSize += node.size;\n      }\n\n      // Count direct vs transitive dependencies\n      let directCount = 0;\n      let transitiveCount = 0;\n      for (const node of graph.packages.values()) {\n        if (node.isDirect) {\n          directCount++;\n        } else {\n          transitiveCount++;\n        }\n      }\n\n      // Output results\n      if (jsonOutput) {\n        const result: any = {\n          totalPackages: graph.totalPackages,\n          directDependencies: directCount,\n          transitiveDependencies: transitiveCount,\n          totalSize,\n        };\n\n        if (duplicates) {\n          result.duplicates = {\n            totalDuplicatePackages: duplicates.totalDuplicatePackages,\n            totalWastedBytes: duplicates.totalWastedBytes,\n            packages: duplicates.duplicates,\n          };\n        }\n\n        if (depth) {\n          result.depth = {\n            maxDepth: depth.maxDepth,\n            averageDepth: depth.averageDepth,\n            longestChain: depth.longestChain,\n          };\n        }\n\n        if (deprecated) {\n          result.deprecated = {\n            totalDeprecated: deprecated.totalDeprecated,\n            packages: deprecated.deprecatedPackages,\n          };\n        }\n\n        ctx.output.json(result);\n      } else {\n        // Human-readable output\n        if (shouldRunAll) {\n          ctx.output.log('\\n=== Dependency Analysis ===\\n');\n          ctx.output.log(`Total packages: ${graph.totalPackages}`);\n          ctx.output.log(`  Direct: ${directCount}`);\n          ctx.output.log(`  Transitive: ${transitiveCount}`);\n          ctx.output.log(`Total disk size: ${formatBytes(totalSize)}\\n`);\n        }\n\n        // Duplicates section\n        if (duplicates) {\n          if (duplicatesOnly) {\n            ctx.output.log('\\n=== Duplicate Packages ===\\n');\n          } else {\n            ctx.output.log('--- Duplicates ---');\n          }\n\n          if (duplicates.totalDuplicatePackages === 0) {\n            ctx.output.log('No duplicate packages found.\\n');\n          } else {\n            ctx.output.log(`Found ${duplicates.totalDuplicatePackages} packages with multiple versions`);\n            ctx.output.log(`Wasted space: ${formatBytes(duplicates.totalWastedBytes)}\\n`);\n\n            for (const dup of duplicates.duplicates) {\n              ctx.output.log(`${dup.package}:`);\n              for (const ver of dup.versions) {\n                ctx.output.log(`  - v${ver.version} (${ver.count} instance${ver.count > 1 ? 's' : ''}, ${formatBytes(ver.size)})`);\n              }\n              ctx.output.log(`  Suggested: v${dup.suggestedVersion}`);\n              ctx.output.log(`  Wasted: ${formatBytes(dup.wastedBytes)}\\n`);\n            }\n          }\n        }\n\n        // Depth section\n        if (depth) {\n          if (depthOnly) {\n            ctx.output.log('\\n=== Dependency Depth Analysis ===\\n');\n          } else {\n            ctx.output.log('--- Depth Analysis ---');\n          }\n\n          ctx.output.log(`Max depth: ${depth.maxDepth}`);\n          ctx.output.log(`Average depth: ${depth.averageDepth.toFixed(2)}\\n`);\n\n          if (depth.longestChain.length > 0) {\n            ctx.output.log('Longest dependency chain:');\n            depth.longestChain.forEach((pkg, idx) => {\n              const indent = '  '.repeat(idx);\n              ctx.output.log(`${indent}${idx + 1}. ${pkg}`);\n            });\n            ctx.output.log('');\n          }\n        }\n\n        // Deprecated section\n        if (deprecated) {\n          if (deprecatedOnly) {\n            ctx.output.log('\\n=== Deprecated Packages ===\\n');\n          } else {\n            ctx.output.log('--- Deprecated Packages ---');\n          }\n\n          if (deprecated.totalDeprecated === 0) {\n            ctx.output.log('No deprecated packages found.\\n');\n          } else {\n            ctx.output.log(`Found ${deprecated.totalDeprecated} deprecated package${deprecated.totalDeprecated > 1 ? 's' : ''}:\\n`);\n\n            for (const dep of deprecated.deprecatedPackages) {\n              ctx.output.log(`${dep.name}@${dep.version}:`);\n              ctx.output.log(`  Message: ${dep.deprecationMessage}`);\n              if (dep.dependedOnBy.length > 0) {\n                ctx.output.log(`  Used by: ${dep.dependedOnBy.slice(0, 5).join(', ')}${dep.dependedOnBy.length > 5 ? ` and ${dep.dependedOnBy.length - 5} more` : ''}`);\n              }\n              ctx.output.log('');\n            }\n          }\n        }\n      }\n\n      return 0;\n    } catch (error) {\n      ctx.output.error(`Failed to analyze dependencies: ${error instanceof Error ? error.message : String(error)}`);\n      return 1;\n    }\n  },\n};\n\nregisterCommand(analyzeCommand);\n\nexport default analyzeCommand;\n","import { readdirSync, readFileSync, statSync, existsSync } from 'node:fs';\nimport { join, dirname, resolve } from 'node:path';\nimport { calculateSize } from '../fs/size.js';\n\nexport interface DependencyNode {\n  name: string;\n  version: string;\n  path: string;\n  size: number;\n  dependencies: string[]; // package@version identifiers\n  isDirect: boolean;\n}\n\nexport interface DependencyGraph {\n  root: {\n    name: string;\n    version: string;\n    path: string;\n    dependencies: string[]; // direct dependency package@version identifiers\n  };\n  packages: Map<string, DependencyNode>; // key: package@version\n  totalPackages: number;\n}\n\ninterface PackageJson {\n  name: string;\n  version: string;\n  dependencies?: Record<string, string>;\n  devDependencies?: Record<string, string>;\n  peerDependencies?: Record<string, string>;\n  optionalDependencies?: Record<string, string>;\n}\n\nfunction readPackageJson(path: string): PackageJson | null {\n  try {\n    const content = readFileSync(path, 'utf-8');\n    return JSON.parse(content);\n  } catch {\n    return null;\n  }\n}\n\nfunction getPackageSize(packagePath: string): number {\n  try {\n    const sizeResult = calculateSize(packagePath, {\n      excludeDirs: ['.git', '.DS_Store', 'node_modules'],\n    });\n    return sizeResult.physicalSize;\n  } catch {\n    return 0;\n  }\n}\n\nfunction findPackageJsonUp(startPath: string): string | null {\n  let currentPath = startPath;\n  while (currentPath !== dirname(currentPath)) {\n    const pkgPath = join(currentPath, 'package.json');\n    if (existsSync(pkgPath)) {\n      return pkgPath;\n    }\n    currentPath = dirname(currentPath);\n  }\n  return null;\n}\n\nexport function buildDependencyGraph(nodeModulesPath: string): DependencyGraph {\n  const packages = new Map<string, DependencyNode>();\n\n  // Find root package.json (go up from node_modules to project root)\n  const projectRoot = dirname(nodeModulesPath);\n  const rootPkgPath = join(projectRoot, 'package.json');\n  const rootPkg = readPackageJson(rootPkgPath);\n\n  if (!rootPkg) {\n    throw new Error(`Could not find package.json at ${rootPkgPath}`);\n  }\n\n  // Collect all direct dependencies from root\n  const rootDirectDeps = new Set<string>();\n  const allRootDeps = {\n    ...rootPkg.dependencies,\n    ...rootPkg.devDependencies,\n  };\n\n  // Recursively walk node_modules\n  function walkNodeModules(nmPath: string, visited = new Set<string>()) {\n    if (!existsSync(nmPath)) {\n      return;\n    }\n\n    // Avoid infinite loops from circular symlinks\n    const realPath = resolve(nmPath);\n    if (visited.has(realPath)) {\n      return;\n    }\n    visited.add(realPath);\n\n    let entries;\n    try {\n      entries = readdirSync(nmPath, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    for (const entry of entries) {\n      const entryPath = join(nmPath, entry.name);\n\n      // Handle scoped packages (@org/package)\n      if (entry.isDirectory() && entry.name.startsWith('@')) {\n        let scopedEntries;\n        try {\n          scopedEntries = readdirSync(entryPath, { withFileTypes: true });\n        } catch {\n          continue;\n        }\n\n        for (const scopedEntry of scopedEntries) {\n          if (scopedEntry.isDirectory()) {\n            const scopedPkgPath = join(entryPath, scopedEntry.name);\n            processPackage(scopedPkgPath, visited);\n          }\n        }\n      } else if (entry.isDirectory()) {\n        processPackage(entryPath, visited);\n      }\n    }\n  }\n\n  function processPackage(packagePath: string, visited: Set<string>) {\n    const pkgJsonPath = join(packagePath, 'package.json');\n    const pkg = readPackageJson(pkgJsonPath);\n\n    if (!pkg) {\n      return;\n    }\n\n    const packageKey = `${pkg.name}@${pkg.version}`;\n\n    // Skip if already processed\n    if (packages.has(packageKey)) {\n      return;\n    }\n\n    // Get dependencies from this package\n    const deps = pkg.dependencies || {};\n    const depsList: string[] = [];\n\n    // For each dependency, try to resolve its version\n    for (const depName of Object.keys(deps)) {\n      // Try to find the actual installed version\n      const resolvedVersion = resolveInstalledVersion(depName, packagePath);\n      if (resolvedVersion) {\n        depsList.push(`${depName}@${resolvedVersion}`);\n      }\n    }\n\n    // Check if this is a direct dependency\n    const isDirect = allRootDeps.hasOwnProperty(pkg.name);\n\n    // Calculate package size\n    const size = getPackageSize(packagePath);\n\n    packages.set(packageKey, {\n      name: pkg.name,\n      version: pkg.version,\n      path: packagePath,\n      size,\n      dependencies: depsList,\n      isDirect,\n    });\n\n    if (isDirect) {\n      rootDirectDeps.add(packageKey);\n    }\n\n    // Walk nested node_modules\n    const nestedNm = join(packagePath, 'node_modules');\n    if (existsSync(nestedNm)) {\n      walkNodeModules(nestedNm, visited);\n    }\n  }\n\n  function resolveInstalledVersion(packageName: string, fromPath: string): string | null {\n    // Try to find the package in node_modules hierarchy\n    let currentPath = fromPath;\n\n    while (currentPath !== dirname(currentPath)) {\n      const nmPath = join(currentPath, 'node_modules');\n      const packagePath = packageName.startsWith('@')\n        ? join(nmPath, packageName)\n        : join(nmPath, packageName);\n\n      const pkgJsonPath = join(packagePath, 'package.json');\n\n      if (existsSync(pkgJsonPath)) {\n        const pkg = readPackageJson(pkgJsonPath);\n        if (pkg && pkg.version) {\n          return pkg.version;\n        }\n      }\n\n      currentPath = dirname(currentPath);\n    }\n\n    return null;\n  }\n\n  // Start walking from the main node_modules\n  walkNodeModules(nodeModulesPath);\n\n  return {\n    root: {\n      name: rootPkg.name,\n      version: rootPkg.version,\n      path: projectRoot,\n      dependencies: Array.from(rootDirectDeps),\n    },\n    packages,\n    totalPackages: packages.size,\n  };\n}\n","import { readdirSync, statSync } from 'node:fs';\nimport { join } from 'node:path';\n\nexport interface ScanOptions {\n  excludeDirs?: string[];\n  followSymlinks?: boolean;\n}\n\nexport interface FileInfo {\n  path: string;\n  size: number;\n  isDirectory: boolean;\n  isSymlink: boolean;\n  ino: number;\n  dev: number;\n}\n\n/**\n * Recursively scan a directory and yield all files\n */\nexport function* scanDirectory(\n  dir: string,\n  options: ScanOptions = {}\n): Generator<FileInfo> {\n  const { excludeDirs = ['.git', '.DS_Store'], followSymlinks = false } = options;\n\n  let entries;\n  try {\n    entries = readdirSync(dir, { withFileTypes: true });\n  } catch (err) {\n    // Skip directories we can't read\n    return;\n  }\n\n  for (const entry of entries) {\n    const fullPath = join(dir, entry.name);\n\n    if (excludeDirs.includes(entry.name)) {\n      continue;\n    }\n\n    let stat;\n    try {\n      stat = statSync(fullPath, { bigint: false });\n    } catch (err) {\n      // Skip files we can't stat\n      continue;\n    }\n\n    const isSymlink = entry.isSymbolicLink();\n\n    if (stat.isDirectory()) {\n      yield {\n        path: fullPath,\n        size: 0,\n        isDirectory: true,\n        isSymlink,\n        ino: stat.ino,\n        dev: stat.dev,\n      };\n\n      // Recurse into directory unless it's a symlink and we're not following them\n      if (!isSymlink || followSymlinks) {\n        yield* scanDirectory(fullPath, options);\n      }\n    } else if (stat.isFile()) {\n      yield {\n        path: fullPath,\n        size: stat.size,\n        isDirectory: false,\n        isSymlink,\n        ino: stat.ino,\n        dev: stat.dev,\n      };\n    }\n  }\n}\n","/**\n * Track hardlinks to avoid counting the same file multiple times\n */\nexport class HardlinkTracker {\n  private seen = new Map<string, boolean>();\n\n  /**\n   * Check if we've seen this inode+dev combination before\n   * @param ino inode number\n   * @param dev device number\n   * @returns true if this is the first time seeing this inode\n   */\n  isFirstOccurrence(ino: number, dev: number): boolean {\n    const key = `${dev}:${ino}`;\n    if (this.seen.has(key)) {\n      return false;\n    }\n    this.seen.set(key, true);\n    return true;\n  }\n\n  /**\n   * Get the count of unique inodes tracked\n   */\n  getUniqueCount(): number {\n    return this.seen.size;\n  }\n\n  /**\n   * Reset the tracker\n   */\n  reset(): void {\n    this.seen.clear();\n  }\n}\n","import { scanDirectory, type ScanOptions } from './scanner.js';\nimport { HardlinkTracker } from './hardlinks.js';\n\nexport interface SizeResult {\n  logicalSize: number;\n  physicalSize: number;\n  fileCount: number;\n  directoryCount: number;\n}\n\n/**\n * Calculate both logical and physical size of a directory\n * - Logical size: sum of all file sizes (counts hardlinks multiple times)\n * - Physical size: sum of unique inodes (counts hardlinks once)\n */\nexport function calculateSize(dir: string, options?: ScanOptions): SizeResult {\n  let logicalSize = 0;\n  let physicalSize = 0;\n  let fileCount = 0;\n  let directoryCount = 0;\n\n  const hardlinkTracker = new HardlinkTracker();\n\n  for (const file of scanDirectory(dir, options)) {\n    if (file.isDirectory) {\n      directoryCount++;\n    } else {\n      fileCount++;\n      logicalSize += file.size;\n\n      // Only count physical size for first occurrence of each inode\n      if (hardlinkTracker.isFirstOccurrence(file.ino, file.dev)) {\n        physicalSize += file.size;\n      }\n    }\n  }\n\n  return {\n    logicalSize,\n    physicalSize,\n    fileCount,\n    directoryCount,\n  };\n}\n\n/**\n * Format bytes into human-readable string\n */\nexport function formatBytes(bytes: number): string {\n  if (bytes === 0) return '0 B';\n\n  const units = ['B', 'KB', 'MB', 'GB', 'TB'];\n  const k = 1024;\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n  return `${(bytes / Math.pow(k, i)).toFixed(2)} ${units[i]}`;\n}\n","import { DependencyGraph, DependencyNode } from './graph.js';\n\nexport interface VersionInfo {\n  version: string;\n  count: number;\n  paths: string[];\n  size: number;\n}\n\nexport interface DuplicateReport {\n  package: string;\n  versions: VersionInfo[];\n  totalInstances: number;\n  wastedBytes: number;\n  suggestedVersion: string;\n}\n\nexport interface DuplicateAnalysis {\n  duplicates: DuplicateReport[];\n  totalWastedBytes: number;\n  totalDuplicatePackages: number;\n}\n\n/**\n * Compares two semver version strings\n * Returns: negative if a < b, 0 if equal, positive if a > b\n */\nfunction compareVersions(a: string, b: string): number {\n  const aParts = a.split('.').map(p => parseInt(p, 10) || 0);\n  const bParts = b.split('.').map(p => parseInt(p, 10) || 0);\n\n  const maxLength = Math.max(aParts.length, bParts.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const aVal = aParts[i] || 0;\n    const bVal = bParts[i] || 0;\n\n    if (aVal !== bVal) {\n      return aVal - bVal;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Detect duplicate packages in dependency graph\n * Groups packages by name and identifies multiple versions\n */\nexport function detectDuplicates(graph: DependencyGraph): DuplicateAnalysis {\n  // Map: packageName -> DependencyNode[]\n  const packagesByName = new Map<string, DependencyNode[]>();\n\n  // Group packages by name\n  for (const node of graph.packages.values()) {\n    const existing = packagesByName.get(node.name) || [];\n    existing.push(node);\n    packagesByName.set(node.name, existing);\n  }\n\n  const duplicates: DuplicateReport[] = [];\n  let totalWastedBytes = 0;\n\n  // Process packages with multiple versions\n  for (const [packageName, nodes] of packagesByName.entries()) {\n    // Group by version to get counts\n    const versionMap = new Map<string, DependencyNode[]>();\n\n    for (const node of nodes) {\n      const existing = versionMap.get(node.version) || [];\n      existing.push(node);\n      versionMap.set(node.version, existing);\n    }\n\n    // Only report if there are multiple unique versions\n    if (versionMap.size > 1) {\n      const versions: VersionInfo[] = [];\n      let totalSize = 0;\n      let maxSize = 0;\n      let totalInstances = 0;\n\n      // Build version info\n      for (const [version, versionNodes] of versionMap.entries()) {\n        const versionSize = versionNodes.reduce((sum, n) => sum + n.size, 0);\n        const count = versionNodes.length;\n\n        versions.push({\n          version,\n          count,\n          paths: versionNodes.map(n => n.path),\n          size: versionSize,\n        });\n\n        totalSize += versionSize;\n        maxSize = Math.max(maxSize, versionSize / count); // Average size per instance\n        totalInstances += count;\n      }\n\n      // Sort versions by semver (highest first)\n      versions.sort((a, b) => compareVersions(b.version, a.version));\n\n      // Suggested version is the highest semver version\n      const suggestedVersion = versions[0]?.version || '';\n\n      // Wasted space calculation:\n      // If we had only one version, we'd have maxSize * totalInstances\n      // But we have totalSize, so wasted = totalSize - maxSize\n      // Better: wasted = sum of all but the largest single instance size\n      const singleInstanceSize = Math.max(...versions.map(v => v.size / v.count));\n      const wastedBytes = Math.round(totalSize - singleInstanceSize);\n\n      duplicates.push({\n        package: packageName,\n        versions,\n        totalInstances,\n        wastedBytes: Math.max(0, wastedBytes),\n        suggestedVersion,\n      });\n\n      totalWastedBytes += Math.max(0, wastedBytes);\n    }\n  }\n\n  // Sort duplicates by wasted bytes descending (highest impact first)\n  duplicates.sort((a, b) => b.wastedBytes - a.wastedBytes);\n\n  return {\n    duplicates,\n    totalWastedBytes,\n    totalDuplicatePackages: duplicates.length,\n  };\n}\n","import { DependencyGraph } from './graph.js';\n\nexport interface DepthAnalysis {\n  maxDepth: number;\n  longestChain: string[];  // Array of package@version\n  depthDistribution: Map<number, string[]>; // depth -> packages at that depth\n  averageDepth: number;\n}\n\ninterface BFSNode {\n  packageId: string;\n  depth: number;\n  path: string[];\n}\n\nexport function analyzeDepth(graph: DependencyGraph): DepthAnalysis {\n  const depthMap = new Map<string, number>();\n  const pathMap = new Map<string, string[]>();\n  const depthDistribution = new Map<number, string[]>();\n\n  // BFS queue starting from root dependencies\n  const queue: BFSNode[] = [];\n  const visited = new Set<string>();\n\n  // Initialize with root's direct dependencies\n  for (const depId of graph.root.dependencies) {\n    queue.push({\n      packageId: depId,\n      depth: 1,\n      path: [depId]\n    });\n  }\n\n  let maxDepth = 0;\n  let longestChainNode: BFSNode | null = null;\n\n  // BFS traversal\n  while (queue.length > 0) {\n    const current = queue.shift()!;\n    const { packageId, depth, path } = current;\n\n    // Skip if we've already visited this package at a shallower or equal depth\n    if (visited.has(packageId)) {\n      continue;\n    }\n\n    visited.add(packageId);\n\n    // Update depth for this package\n    depthMap.set(packageId, depth);\n    pathMap.set(packageId, path);\n\n    // Update depth distribution\n    if (!depthDistribution.has(depth)) {\n      depthDistribution.set(depth, []);\n    }\n    depthDistribution.get(depth)!.push(packageId);\n\n    // Track maximum depth and longest chain\n    if (depth > maxDepth) {\n      maxDepth = depth;\n      longestChainNode = current;\n    }\n\n    // Get package node from graph\n    const packageNode = graph.packages.get(packageId);\n    if (packageNode) {\n      // Add children to queue\n      for (const childId of packageNode.dependencies) {\n        // Only add child if it exists in the graph and hasn't been visited\n        if (!visited.has(childId) && graph.packages.has(childId)) {\n          queue.push({\n            packageId: childId,\n            depth: depth + 1,\n            path: [...path, childId]\n          });\n        }\n      }\n    }\n  }\n\n  // Calculate average depth\n  const totalDepth = Array.from(depthMap.values()).reduce((sum, d) => sum + d, 0);\n  const averageDepth = depthMap.size > 0 ? totalDepth / depthMap.size : 0;\n\n  // Get longest chain\n  const longestChain = longestChainNode ? longestChainNode.path : [];\n\n  return {\n    maxDepth,\n    longestChain,\n    depthDistribution,\n    averageDepth\n  };\n}\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { DependencyGraph } from './graph.js';\n\nexport interface DeprecatedPackage {\n  name: string;\n  version: string;\n  path: string;\n  deprecationMessage: string;\n  dependedOnBy: string[];  // packages that depend on this\n}\n\nexport interface DeprecationReport {\n  deprecatedPackages: DeprecatedPackage[];\n  totalDeprecated: number;\n}\n\nexport function detectDeprecated(graph: DependencyGraph, rootDir: string): DeprecationReport {\n  const deprecatedPackages: DeprecatedPackage[] = [];\n  const deprecatedMap = new Map<string, DeprecatedPackage>();\n\n  // Iterate through all packages in the graph\n  for (const [packageId, node] of graph.packages.entries()) {\n    const packageJsonPath = path.join(node.path, 'package.json');\n\n    // Check if package.json exists\n    if (!fs.existsSync(packageJsonPath)) {\n      continue;\n    }\n\n    try {\n      // Read and parse package.json\n      const packageJsonContent = fs.readFileSync(packageJsonPath, 'utf-8');\n      const packageJson = JSON.parse(packageJsonContent);\n\n      // Check for deprecated field\n      if (packageJson.deprecated) {\n        // Handle both string and boolean deprecated fields\n        const deprecationMessage = typeof packageJson.deprecated === 'string'\n          ? packageJson.deprecated\n          : 'This package is deprecated';\n\n        const deprecatedPackage: DeprecatedPackage = {\n          name: node.name,\n          version: node.version,\n          path: node.path,\n          deprecationMessage,\n          dependedOnBy: []\n        };\n\n        deprecatedMap.set(packageId, deprecatedPackage);\n      }\n    } catch (error) {\n      // Silently skip if package.json can't be read or parsed\n      continue;\n    }\n  }\n\n  // Find which packages depend on deprecated ones\n  for (const [packageId, deprecatedPkg] of deprecatedMap.entries()) {\n    // Check all packages to find dependents\n    for (const [dependerPackageId, dependerNode] of graph.packages.entries()) {\n      // Check if this package depends on the deprecated package\n      if (dependerNode.dependencies.includes(packageId)) {\n        const dependerIdentifier = `${dependerNode.name}@${dependerNode.version}`;\n        deprecatedPkg.dependedOnBy.push(dependerIdentifier);\n      }\n    }\n\n    // Also check if root directly depends on this deprecated package\n    if (graph.root.dependencies.includes(packageId)) {\n      deprecatedPkg.dependedOnBy.push('root');\n    }\n\n    deprecatedPackages.push(deprecatedPkg);\n  }\n\n  return {\n    deprecatedPackages,\n    totalDeprecated: deprecatedPackages.length\n  };\n}\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { getCacheRoot } from '../utils/paths.js';\nimport { getLogger } from '../observability/logger.js';\n\nexport interface CacheConfig {\n  root: string;\n}\n\nexport interface CacheEntry {\n  key: string;\n  path: string;\n  size: number;\n  createdAt: Date;\n  accessedAt: Date;\n}\n\nexport class CacheManager {\n  private root: string;\n  private initialized: boolean = false;\n\n  constructor(config?: Partial<CacheConfig>) {\n    this.root = config?.root ?? getCacheRoot();\n  }\n\n  // Ensure cache directory structure exists\n  async initialize(): Promise<void> {\n    if (this.initialized) return;\n\n    const logger = getLogger();\n    const dirs = [\n      this.root,\n      path.join(this.root, 'packages'),\n      path.join(this.root, 'metadata'),\n      path.join(this.root, 'tmp'),\n    ];\n\n    for (const dir of dirs) {\n      if (!fs.existsSync(dir)) {\n        logger.debug('Creating cache directory', { path: dir });\n        fs.mkdirSync(dir, { recursive: true, mode: 0o755 });\n      }\n    }\n\n    this.initialized = true;\n    logger.info('Cache initialized', { root: this.root });\n  }\n\n  // Get the root cache directory\n  getRoot(): string {\n    return this.root;\n  }\n\n  // Get path for a specific cache type\n  getPath(type: 'packages' | 'metadata' | 'tmp', ...parts: string[]): string {\n    return path.join(this.root, type, ...parts);\n  }\n\n  // Get path for a package in cache\n  getPackagePath(name: string, version: string): string {\n    // Use scoped package handling\n    const safeName = name.replace(/\\//g, '+');\n    return this.getPath('packages', safeName, version);\n  }\n\n  // Check if a package is cached\n  async hasPackage(name: string, version: string): Promise<boolean> {\n    const pkgPath = this.getPackagePath(name, version);\n    return fs.existsSync(pkgPath);\n  }\n\n  // Get cache stats\n  async getStats(): Promise<CacheStats> {\n    await this.initialize();\n\n    const packagesDir = this.getPath('packages');\n    const stats: CacheStats = {\n      root: this.root,\n      totalSize: 0,\n      packageCount: 0,\n      oldestEntry: null,\n      newestEntry: null,\n    };\n\n    if (!fs.existsSync(packagesDir)) {\n      return stats;\n    }\n\n    const entries = await this.scanDirectory(packagesDir);\n    stats.packageCount = entries.length;\n    stats.totalSize = entries.reduce((sum, e) => sum + e.size, 0);\n\n    if (entries.length > 0) {\n      entries.sort((a, b) => a.createdAt.getTime() - b.createdAt.getTime());\n      stats.oldestEntry = entries[0]!.createdAt;\n      stats.newestEntry = entries[entries.length - 1]!.createdAt;\n    }\n\n    return stats;\n  }\n\n  // Scan a directory recursively for cache entries\n  private async scanDirectory(dir: string): Promise<CacheEntry[]> {\n    const entries: CacheEntry[] = [];\n\n    if (!fs.existsSync(dir)) return entries;\n\n    const items = fs.readdirSync(dir, { withFileTypes: true });\n\n    for (const item of items) {\n      const fullPath = path.join(dir, item.name);\n\n      if (item.isDirectory()) {\n        // Recurse into subdirectories\n        const subEntries = await this.scanDirectory(fullPath);\n        entries.push(...subEntries);\n      } else if (item.isFile()) {\n        const stat = fs.statSync(fullPath);\n        entries.push({\n          key: path.relative(this.root, fullPath),\n          path: fullPath,\n          size: stat.size,\n          createdAt: stat.birthtime,\n          accessedAt: stat.atime,\n        });\n      }\n    }\n\n    return entries;\n  }\n\n  // Clean up temporary files\n  async cleanTmp(): Promise<number> {\n    const tmpDir = this.getPath('tmp');\n    if (!fs.existsSync(tmpDir)) return 0;\n\n    let cleaned = 0;\n    const items = fs.readdirSync(tmpDir);\n\n    for (const item of items) {\n      const fullPath = path.join(tmpDir, item);\n      fs.rmSync(fullPath, { recursive: true, force: true });\n      cleaned++;\n    }\n\n    return cleaned;\n  }\n}\n\nexport interface CacheStats {\n  root: string;\n  totalSize: number;\n  packageCount: number;\n  oldestEntry: Date | null;\n  newestEntry: Date | null;\n}\n\n// Singleton instance\nlet cacheManager: CacheManager | null = null;\n\nexport function getCacheManager(config?: Partial<CacheConfig>): CacheManager {\n  if (!cacheManager) {\n    cacheManager = new CacheManager(config);\n  }\n  return cacheManager;\n}\n\nexport function setCacheManager(manager: CacheManager): void {\n  cacheManager = manager;\n}\n","import * as os from 'node:os';\nimport * as path from 'node:path';\n\nexport function getCacheRoot(): string {\n  const platform = os.platform();\n\n  // Check XDG_CACHE_HOME first (Linux standard)\n  if (process.env['XDG_CACHE_HOME']) {\n    return path.join(process.env['XDG_CACHE_HOME'], 'better');\n  }\n\n  switch (platform) {\n    case 'darwin':\n      return path.join(os.homedir(), 'Library', 'Caches', 'better');\n    case 'win32':\n      return path.join(process.env['LOCALAPPDATA'] ?? os.homedir(), 'better', 'cache');\n    default:\n      // Linux and others\n      return path.join(os.homedir(), '.cache', 'better');\n  }\n}\n\nexport function getConfigRoot(): string {\n  const platform = os.platform();\n\n  if (process.env['XDG_CONFIG_HOME']) {\n    return path.join(process.env['XDG_CONFIG_HOME'], 'better');\n  }\n\n  switch (platform) {\n    case 'darwin':\n      return path.join(os.homedir(), 'Library', 'Application Support', 'better');\n    case 'win32':\n      return path.join(process.env['APPDATA'] ?? os.homedir(), 'better');\n    default:\n      return path.join(os.homedir(), '.config', 'better');\n  }\n}\n\nexport function getDataRoot(): string {\n  const platform = os.platform();\n\n  if (process.env['XDG_DATA_HOME']) {\n    return path.join(process.env['XDG_DATA_HOME'], 'better');\n  }\n\n  switch (platform) {\n    case 'darwin':\n      return path.join(os.homedir(), 'Library', 'Application Support', 'better', 'data');\n    case 'win32':\n      return path.join(process.env['LOCALAPPDATA'] ?? os.homedir(), 'better', 'data');\n    default:\n      return path.join(os.homedir(), '.local', 'share', 'better');\n  }\n}\n\nexport function ensureDir(dir: string): void {\n  const fs = require('node:fs');\n  if (!fs.existsSync(dir)) {\n    fs.mkdirSync(dir, { recursive: true, mode: 0o755 });\n  }\n}\n","import * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { getCacheManager, type CacheEntry } from './manager.js';\nimport { getLogger } from '../observability/logger.js';\n\nexport interface GCOptions {\n  maxAge?: number | undefined; // milliseconds, default 30 days\n  dryRun?: boolean | undefined;\n}\n\nexport interface GCResult {\n  entriesRemoved: number;\n  bytesFreed: number;\n  entries: { path: string; size: number; age: number }[];\n}\n\ninterface OldEntry {\n  path: string;\n  size: number;\n  createdAt: Date;\n}\n\nasync function findOldEntries(\n  dir: string,\n  maxAge: number,\n  now: number\n): Promise<OldEntry[]> {\n  const oldEntries: OldEntry[] = [];\n\n  if (!fs.existsSync(dir)) return oldEntries;\n\n  const items = fs.readdirSync(dir, { withFileTypes: true });\n\n  for (const item of items) {\n    const fullPath = path.join(dir, item.name);\n\n    if (item.isDirectory()) {\n      // Check if this is a package version directory (leaf node)\n      const hasFiles = fs\n        .readdirSync(fullPath, { withFileTypes: true })\n        .some((subItem) => subItem.isFile());\n\n      if (hasFiles) {\n        // This is a package version directory\n        const stat = fs.statSync(fullPath);\n        const age = now - stat.birthtime.getTime();\n\n        if (age > maxAge) {\n          // Calculate directory size\n          const size = getDirectorySize(fullPath);\n          oldEntries.push({\n            path: fullPath,\n            size,\n            createdAt: stat.birthtime,\n          });\n        }\n      } else {\n        // Recurse into package name directories\n        const subEntries = await findOldEntries(fullPath, maxAge, now);\n        oldEntries.push(...subEntries);\n      }\n    }\n  }\n\n  return oldEntries;\n}\n\nfunction getDirectorySize(dir: string): number {\n  let size = 0;\n\n  const items = fs.readdirSync(dir, { withFileTypes: true });\n\n  for (const item of items) {\n    const fullPath = path.join(dir, item.name);\n\n    if (item.isDirectory()) {\n      size += getDirectorySize(fullPath);\n    } else if (item.isFile()) {\n      const stat = fs.statSync(fullPath);\n      size += stat.size;\n    }\n  }\n\n  return size;\n}\n\nexport async function runGarbageCollection(\n  options: GCOptions = {}\n): Promise<GCResult> {\n  const logger = getLogger();\n  const cache = getCacheManager();\n  const maxAge = options.maxAge ?? 30 * 24 * 60 * 60 * 1000; // 30 days\n  const now = Date.now();\n\n  await cache.initialize();\n\n  const packagesDir = cache.getPath('packages');\n\n  const result: GCResult = {\n    entriesRemoved: 0,\n    bytesFreed: 0,\n    entries: [],\n  };\n\n  // Scan for old entries\n  const oldEntries = await findOldEntries(packagesDir, maxAge, now);\n\n  for (const entry of oldEntries) {\n    result.entries.push({\n      path: entry.path,\n      size: entry.size,\n      age: now - entry.createdAt.getTime(),\n    });\n    result.bytesFreed += entry.size;\n\n    if (!options.dryRun) {\n      fs.rmSync(entry.path, { recursive: true, force: true });\n      result.entriesRemoved++;\n    }\n  }\n\n  if (options.dryRun) {\n    logger.info('Dry run - no files removed', { wouldRemove: oldEntries.length });\n  } else {\n    logger.info('Garbage collection complete', { removed: result.entriesRemoved });\n  }\n\n  return result;\n}\n","import type { Command, CommandContext } from './index.js';\nimport { registerCommand } from './index.js';\nimport { getCacheManager } from '../../cache/manager.js';\nimport { formatBytes } from '../../fs/size.js';\nimport { runGarbageCollection } from '../../cache/gc.js';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\n\nconst cacheCommand: Command = {\n  name: 'cache',\n  description: 'Manage dependency cache',\n  async run(ctx: CommandContext): Promise<number> {\n    const subcommand = ctx.args.positionals[0];\n    const maxAgeFlag = ctx.args.flags['max-age'];\n    const options: {\n      json: boolean;\n      dryRun: boolean;\n      maxAge?: number;\n    } = {\n      json: ctx.args.flags['json'] === true,\n      dryRun: ctx.args.flags['dry-run'] === true,\n    };\n\n    if (typeof maxAgeFlag === 'number') {\n      options.maxAge = maxAgeFlag;\n    }\n\n    switch (subcommand) {\n      case 'stats':\n        await cacheStatsCommand(ctx, options);\n        break;\n      case 'clean':\n        await cacheCleanCommand(ctx, options);\n        break;\n      case 'gc':\n        await cacheGCCommand(ctx, options);\n        break;\n      case 'explain':\n        await cacheExplainCommand(ctx, options);\n        break;\n      default:\n        ctx.output.error(`Unknown cache subcommand: ${subcommand}`);\n        ctx.output.log('Available: stats, clean, gc, explain');\n        return 1;\n    }\n\n    return 0;\n  },\n};\n\nasync function cacheStatsCommand(\n  ctx: CommandContext,\n  options: { json: boolean }\n): Promise<void> {\n  const cache = getCacheManager();\n  const stats = await cache.getStats();\n\n  if (options.json) {\n    ctx.output.json({\n      root: stats.root,\n      totalSize: stats.totalSize,\n      packageCount: stats.packageCount,\n      oldestEntry: stats.oldestEntry?.toISOString() ?? null,\n      newestEntry: stats.newestEntry?.toISOString() ?? null,\n    });\n  } else {\n    ctx.output.log('Cache Statistics:');\n    ctx.output.log(`  Location: ${stats.root}`);\n    ctx.output.log(`  Total Size: ${formatBytes(stats.totalSize)}`);\n    ctx.output.log(`  Packages: ${stats.packageCount}`);\n    if (stats.oldestEntry) {\n      ctx.output.log(`  Oldest: ${stats.oldestEntry.toISOString()}`);\n    }\n    if (stats.newestEntry) {\n      ctx.output.log(`  Newest: ${stats.newestEntry.toISOString()}`);\n    }\n  }\n}\n\nasync function cacheCleanCommand(\n  ctx: CommandContext,\n  options: { json: boolean }\n): Promise<void> {\n  const cache = getCacheManager();\n  const cleaned = await cache.cleanTmp();\n\n  if (options.json) {\n    ctx.output.json({ cleaned });\n  } else {\n    ctx.output.log(`Cleaned ${cleaned} temporary files`);\n  }\n}\n\nasync function cacheGCCommand(\n  ctx: CommandContext,\n  options: { json: boolean; dryRun: boolean; maxAge?: number }\n): Promise<void> {\n  const gcOptions: { dryRun: boolean; maxAge?: number } = {\n    dryRun: options.dryRun,\n  };\n\n  if (options.maxAge !== undefined) {\n    gcOptions.maxAge = options.maxAge;\n  }\n\n  const result = await runGarbageCollection(gcOptions);\n\n  if (options.json) {\n    ctx.output.json(result);\n  } else {\n    if (options.dryRun) {\n      ctx.output.log(\n        `Would remove ${result.entriesRemoved} packages (${formatBytes(result.bytesFreed)})`\n      );\n    } else {\n      ctx.output.log(\n        `Removed ${result.entriesRemoved} packages (${formatBytes(result.bytesFreed)})`\n      );\n    }\n  }\n}\n\nasync function cacheExplainCommand(\n  ctx: CommandContext,\n  options: { json: boolean }\n): Promise<void> {\n  const packageSpec = ctx.args.positionals[1];\n\n  if (!packageSpec) {\n    ctx.output.error('Usage: better cache explain <package[@version]>');\n    process.exit(1);\n  }\n\n  const cache = getCacheManager();\n  const [name, version] = parsePackageSpec(packageSpec);\n\n  const result = {\n    package: name,\n    version: version || 'any',\n    cached: false,\n    path: null as string | null,\n    reason: '' as string,\n  };\n\n  if (version) {\n    const isCached = await cache.hasPackage(name, version);\n    if (isCached) {\n      result.cached = true;\n      result.path = cache.getPackagePath(name, version);\n      result.reason = 'Package found in cache';\n    } else {\n      result.reason = 'Package not in cache - will be downloaded on next install';\n    }\n  } else {\n    // Check for any version\n    const packagesDir = cache.getPath('packages');\n    const safeName = name.replace(/\\//g, '+');\n    const packageDir = path.join(packagesDir, safeName);\n\n    if (fs.existsSync(packageDir)) {\n      const versions = fs.readdirSync(packageDir);\n      result.cached = true;\n      result.path = packageDir;\n      result.reason = `Found ${versions.length} cached version(s): ${versions.join(', ')}`;\n    } else {\n      result.reason = 'No versions of this package are cached';\n    }\n  }\n\n  if (options.json) {\n    ctx.output.json(result);\n  } else {\n    ctx.output.log(`Package: ${result.package}${result.version !== 'any' ? '@' + result.version : ''}`);\n    ctx.output.log(`Cached: ${result.cached ? 'Yes' : 'No'}`);\n    if (result.path) {\n      ctx.output.log(`Path: ${result.path}`);\n    }\n    ctx.output.log(`Status: ${result.reason}`);\n  }\n}\n\nfunction parsePackageSpec(spec: string): [string, string | undefined] {\n  // Handle @scope/package@version\n  const lastAt = spec.lastIndexOf('@');\n  if (lastAt > 0) {\n    return [spec.slice(0, lastAt), spec.slice(lastAt + 1)];\n  }\n  return [spec, undefined];\n}\n\nregisterCommand(cacheCommand);\n\nexport default cacheCommand;\n","import * as path from 'node:path';\nimport type { Command, CommandContext } from './index.js';\nimport { registerCommand } from './index.js';\nimport { buildDependencyGraph } from '../../analyzer/graph.js';\nimport { detectDuplicates } from '../../analyzer/duplicates.js';\nimport { analyzeDepth } from '../../analyzer/depth.js';\nimport { detectDeprecated } from '../../analyzer/deprecation.js';\nimport { HealthEngine, type HealthCheckContext, type HealthReport } from '../../doctor/engine.js';\nimport { allChecks } from '../../doctor/checks/index.js';\nimport { getLogger } from '../../observability/logger.js';\n\nconst doctorCommand: Command = {\n  name: 'doctor',\n  description: 'Check system health and configuration',\n  async run(ctx: CommandContext): Promise<number> {\n    const logger = getLogger();\n    const cwd = process.cwd();\n\n    // Parse options from flags\n    const jsonOutput = ctx.args.flags['json'] === true;\n    const fix = ctx.args.flags['fix'] === true;\n    const threshold = typeof ctx.args.flags['threshold'] === 'string'\n      ? parseInt(ctx.args.flags['threshold'], 10)\n      : (typeof ctx.config['healthThreshold'] === 'number' ? ctx.config['healthThreshold'] : 70);\n\n    logger.info('Running health checks', { cwd, threshold });\n\n    try {\n      // Build context\n      const nodeModulesPath = path.join(cwd, 'node_modules');\n      const graph = buildDependencyGraph(nodeModulesPath);\n      const duplicates = detectDuplicates(graph);\n      const depth = analyzeDepth(graph);\n      const deprecated = detectDeprecated(graph, nodeModulesPath);\n\n      const context: HealthCheckContext = {\n        cwd,\n        graph,\n        duplicates,\n        depth,\n        deprecated,\n      };\n\n      // Run checks\n      const engine = new HealthEngine();\n      allChecks.forEach(check => engine.register(check));\n      const report = await engine.run(context);\n\n      // Output\n      if (jsonOutput) {\n        console.log(JSON.stringify(report, null, 2));\n      } else {\n        printReport(report, threshold, ctx.output);\n      }\n\n      // Exit code based on threshold\n      if (report.score < threshold) {\n        logger.warn('Health score below threshold', { score: report.score, threshold });\n        return 1;\n      }\n\n      return 0;\n    } catch (error) {\n      logger.error('Doctor command failed', { error: String(error) });\n      ctx.output.error(`Failed to run health checks: ${error instanceof Error ? error.message : String(error)}`);\n      return 1;\n    }\n  },\n};\n\nfunction printReport(report: HealthReport, threshold: number, output: any): void {\n  const scoreColor = report.score >= threshold ? '32' : '31'; // green/red\n  console.log(`\\nHealth Score: \\x1b[${scoreColor}m${report.score}/100\\x1b[0m\\n`);\n\n  const errors = report.findings.filter(f => f.severity === 'error');\n  const warnings = report.findings.filter(f => f.severity === 'warning');\n  const infos = report.findings.filter(f => f.severity === 'info');\n\n  if (errors.length > 0) {\n    console.log(`ERRORS (${errors.length}):`);\n    errors.forEach(f => console.log(`  - [${f.checkId}] ${f.message}`));\n    console.log('');\n  }\n\n  if (warnings.length > 0) {\n    console.log(`WARNINGS (${warnings.length}):`);\n    warnings.forEach(f => console.log(`  - [${f.checkId}] ${f.message}`));\n    console.log('');\n  }\n\n  if (infos.length > 0) {\n    console.log(`INFO (${infos.length}):`);\n    infos.forEach(f => console.log(`  - [${f.checkId}] ${f.message}`));\n    console.log('');\n  }\n\n  if (report.findings.length === 0) {\n    console.log('No issues found!\\n');\n  }\n\n  console.log(`Run 'better doctor --fix' to attempt automatic fixes.`);\n}\n\nregisterCommand(doctorCommand);\n\nexport default doctorCommand;\n","import { DependencyGraph } from '../analyzer/graph.js';\nimport { DepthAnalysis } from '../analyzer/depth.js';\nimport { DeprecationReport } from '../analyzer/deprecation.js';\nimport { DuplicateAnalysis } from '../analyzer/duplicates.js';\n\nexport type Severity = 'error' | 'warning' | 'info';\n\nexport interface Finding {\n  checkId: string;\n  severity: Severity;\n  message: string;\n  package?: string;\n  suggestion?: string;\n  weight: number;\n}\n\nexport interface HealthCheck {\n  id: string;\n  name: string;\n  description: string;\n  run(context: HealthCheckContext): Promise<Finding[]>;\n}\n\nexport interface HealthCheckContext {\n  cwd: string;\n  graph: DependencyGraph;\n  duplicates: DuplicateAnalysis;\n  depth: DepthAnalysis;\n  deprecated: DeprecationReport;\n}\n\nexport interface HealthReport {\n  score: number;\n  findings: Finding[];\n  checksPassed: string[];\n  checksFailed: string[];\n}\n\nexport class HealthEngine {\n  private checks: HealthCheck[] = [];\n\n  register(check: HealthCheck): void {\n    this.checks.push(check);\n  }\n\n  async run(context: HealthCheckContext): Promise<HealthReport> {\n    // Run all checks in parallel\n    const results = await Promise.all(\n      this.checks.map((check) => check.run(context))\n    );\n\n    const findings = results.flat();\n\n    // Import score calculator\n    const { calculateScore } = await import('./score.js');\n    const score = calculateScore(findings);\n\n    // Determine which checks passed/failed\n    const checksPassed: string[] = [];\n    const checksFailed: string[] = [];\n\n    for (let i = 0; i < this.checks.length; i++) {\n      const result = results[i];\n      const check = this.checks[i];\n      if (result && check) {\n        if (result.length === 0) {\n          checksPassed.push(check.id);\n        } else {\n          checksFailed.push(check.id);\n        }\n      }\n    }\n\n    return {\n      score,\n      findings,\n      checksPassed,\n      checksFailed,\n    };\n  }\n}\n","import { HealthCheck, Finding, HealthCheckContext } from '../engine.js';\n\nexport const duplicatesCheck: HealthCheck = {\n  id: 'duplicates',\n  name: 'Duplicate Packages',\n  description: 'Checks for duplicate package versions',\n\n  async run(context: HealthCheckContext): Promise<Finding[]> {\n    const findings: Finding[] = [];\n    const { duplicates } = context;\n\n    // Weight: 2 each, max 20 total\n    const maxFindings = 10; // 10 * 2 = 20 max weight\n    const duplicatesToReport = duplicates.duplicates.slice(0, maxFindings);\n\n    for (const dup of duplicatesToReport) {\n      findings.push({\n        checkId: 'duplicates',\n        severity: 'warning',\n        message: `Package '${dup.package}' has ${dup.versions.length} versions installed`,\n        package: dup.package,\n        suggestion: `Run 'npm dedupe' to consolidate package versions`,\n        weight: 2,\n      });\n    }\n\n    return findings;\n  },\n};\n","import { HealthCheck, Finding, HealthCheckContext } from '../engine.js';\n\nexport const deprecatedCheck: HealthCheck = {\n  id: 'deprecated',\n  name: 'Deprecated Packages',\n  description: 'Checks for deprecated packages',\n\n  async run(context: HealthCheckContext): Promise<Finding[]> {\n    const findings: Finding[] = [];\n    const { deprecated } = context;\n\n    // Weight: 5 each, max 25 total\n    const maxFindings = 5; // 5 * 5 = 25 max weight\n    const deprecatedToReport = deprecated.deprecatedPackages.slice(0, maxFindings);\n\n    for (const dep of deprecatedToReport) {\n      const message = dep.deprecationMessage\n        ? `Package '${dep.name}@${dep.version}' is deprecated: ${dep.deprecationMessage}`\n        : `Package '${dep.name}@${dep.version}' is deprecated`;\n\n      findings.push({\n        checkId: 'deprecated',\n        severity: 'error',\n        message,\n        package: dep.name,\n        suggestion: 'Find an alternative package or remove if unused',\n        weight: 5,\n      });\n    }\n\n    return findings;\n  },\n};\n","import { HealthCheck, Finding, HealthCheckContext } from '../engine.js';\n\nexport const depthCheck: HealthCheck = {\n  id: 'depth',\n  name: 'Excessive Depth',\n  description: 'Checks for excessive dependency depth',\n\n  async run(context: HealthCheckContext): Promise<Finding[]> {\n    const findings: Finding[] = [];\n    const { depth } = context;\n\n    // Weight: 10 if max depth > 10\n    const threshold = 10;\n\n    if (depth.maxDepth > threshold) {\n      findings.push({\n        checkId: 'depth',\n        severity: 'warning',\n        message: `Dependency tree depth is ${depth.maxDepth}, exceeding threshold of ${threshold}`,\n        suggestion: 'Consider flattening dependencies or reviewing dependency structure',\n        weight: 10,\n      });\n    }\n\n    return findings;\n  },\n};\n","import { HealthCheck, Finding, HealthCheckContext } from '../engine.js';\nimport { promises as fs } from 'node:fs';\nimport * as path from 'node:path';\n\n/**\n * Get directory size recursively\n */\nasync function getDirectorySize(dirPath: string): Promise<number> {\n  let totalSize = 0;\n\n  try {\n    const entries = await fs.readdir(dirPath, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const fullPath = path.join(dirPath, entry.name);\n\n      if (entry.isDirectory()) {\n        totalSize += await getDirectorySize(fullPath);\n      } else if (entry.isFile()) {\n        const stats = await fs.stat(fullPath);\n        totalSize += stats.size;\n      }\n    }\n  } catch (error) {\n    // Ignore permission errors and continue\n  }\n\n  return totalSize;\n}\n\nexport const sizeCheck: HealthCheck = {\n  id: 'size',\n  name: 'Large node_modules',\n  description: 'Checks for large node_modules directory',\n\n  async run(context: HealthCheckContext): Promise<Finding[]> {\n    const findings: Finding[] = [];\n    const nodeModulesPath = path.join(context.cwd, 'node_modules');\n\n    try {\n      // Check if node_modules exists\n      await fs.access(nodeModulesPath);\n\n      // Calculate size\n      const sizeBytes = await getDirectorySize(nodeModulesPath);\n      const sizeMB = sizeBytes / (1024 * 1024);\n\n      // Weight: 15 if size > 500MB\n      const threshold = 500;\n\n      if (sizeMB > threshold) {\n        findings.push({\n          checkId: 'size',\n          severity: 'warning',\n          message: `node_modules is ${sizeMB.toFixed(2)}MB, exceeding ${threshold}MB threshold`,\n          suggestion: 'Consider removing unused dependencies or using lighter alternatives',\n          weight: 15,\n        });\n      }\n    } catch (error) {\n      // node_modules doesn't exist or can't be accessed - not a finding\n    }\n\n    return findings;\n  },\n};\n","export { duplicatesCheck } from './duplicates.js';\nexport { deprecatedCheck } from './deprecated.js';\nexport { depthCheck } from './depth.js';\nexport { sizeCheck } from './size.js';\n\nimport { duplicatesCheck } from './duplicates.js';\nimport { deprecatedCheck } from './deprecated.js';\nimport { depthCheck } from './depth.js';\nimport { sizeCheck } from './size.js';\n\nexport const allChecks = [\n  duplicatesCheck,\n  deprecatedCheck,\n  depthCheck,\n  sizeCheck,\n];\n","import * as http from 'node:http';\nimport * as fs from 'node:fs';\nimport * as path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { getCacheManager } from '../cache/manager.js';\nimport { buildDependencyGraph } from '../analyzer/graph.js';\nimport { detectDuplicates } from '../analyzer/duplicates.js';\nimport { analyzeDepth } from '../analyzer/depth.js';\nimport { detectDeprecated } from '../analyzer/deprecation.js';\nimport { HealthEngine } from '../doctor/engine.js';\nimport { depthCheck } from '../doctor/checks/depth.js';\nimport { duplicatesCheck } from '../doctor/checks/duplicates.js';\nimport { deprecatedCheck } from '../doctor/checks/deprecated.js';\nimport { sizeCheck } from '../doctor/checks/size.js';\nimport { calculateSize } from '../fs/size.js';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport interface ServerConfig {\n  port: number;\n  cwd: string;\n}\n\nexport class WebServer {\n  private server: http.Server | null = null;\n  private config: ServerConfig;\n\n  constructor(config: ServerConfig) {\n    this.config = config;\n  }\n\n  async start(): Promise<void> {\n    this.server = http.createServer((req, res) => {\n      this.handleRequest(req, res).catch(err => {\n        console.error('Request handler error:', err);\n        if (!res.headersSent) {\n          res.writeHead(500, { 'Content-Type': 'text/plain' });\n          res.end('Internal Server Error');\n        }\n      });\n    });\n\n    return new Promise((resolve, reject) => {\n      this.server!.listen(this.config.port, () => {\n        console.log(`Server listening on http://localhost:${this.config.port}`);\n        resolve();\n      });\n\n      this.server!.on('error', reject);\n    });\n  }\n\n  async stop(): Promise<void> {\n    if (!this.server) return;\n\n    return new Promise((resolve, reject) => {\n      this.server!.close(err => {\n        if (err) reject(err);\n        else resolve();\n      });\n    });\n  }\n\n  private async handleRequest(\n    req: http.IncomingMessage,\n    res: http.ServerResponse\n  ): Promise<void> {\n    const url = new URL(req.url || '/', `http://${req.headers.host}`);\n\n    // Add CORS headers for local development\n    res.setHeader('Access-Control-Allow-Origin', '*');\n    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\n    if (req.method === 'OPTIONS') {\n      res.writeHead(204);\n      res.end();\n      return;\n    }\n\n    if (req.method !== 'GET') {\n      res.writeHead(405, { 'Content-Type': 'text/plain' });\n      res.end('Method Not Allowed');\n      return;\n    }\n\n    // API endpoints\n    if (url.pathname.startsWith('/api/')) {\n      await this.handleApiRequest(url.pathname, res);\n      return;\n    }\n\n    // Static file serving\n    await this.handleStaticFile(url.pathname, res);\n  }\n\n  private async handleApiRequest(\n    pathname: string,\n    res: http.ServerResponse\n  ): Promise<void> {\n    res.setHeader('Content-Type', 'application/json');\n\n    try {\n      if (pathname === '/api/analyze') {\n        const data = await this.getAnalyzeData();\n        res.writeHead(200);\n        res.end(JSON.stringify(data, null, 2));\n      } else if (pathname === '/api/health') {\n        const data = await this.getHealthData();\n        res.writeHead(200);\n        res.end(JSON.stringify(data, null, 2));\n      } else if (pathname === '/api/cache/stats') {\n        const data = await this.getCacheStats();\n        res.writeHead(200);\n        res.end(JSON.stringify(data, null, 2));\n      } else {\n        res.writeHead(404);\n        res.end(JSON.stringify({ error: 'Not Found' }));\n      }\n    } catch (error) {\n      console.error('API error:', error);\n      res.writeHead(500);\n      res.end(JSON.stringify({\n        error: 'Internal Server Error',\n        message: error instanceof Error ? error.message : String(error)\n      }));\n    }\n  }\n\n  private async handleStaticFile(\n    pathname: string,\n    res: http.ServerResponse\n  ): Promise<void> {\n    // Serve index.html for root path\n    if (pathname === '/') {\n      pathname = '/index.html';\n    }\n\n    // Security: prevent directory traversal\n    const safePath = path.normalize(pathname).replace(/^(\\.\\.[\\/\\\\])+/, '');\n    const publicDir = path.join(__dirname, 'public');\n    const filePath = path.join(publicDir, safePath);\n\n    // Ensure file is within public directory\n    if (!filePath.startsWith(publicDir)) {\n      res.writeHead(403, { 'Content-Type': 'text/plain' });\n      res.end('Forbidden');\n      return;\n    }\n\n    // Check if file exists\n    if (!fs.existsSync(filePath) || !fs.statSync(filePath).isFile()) {\n      res.writeHead(404, { 'Content-Type': 'text/plain' });\n      res.end('Not Found');\n      return;\n    }\n\n    // Determine content type\n    const ext = path.extname(filePath).toLowerCase();\n    const contentTypes: Record<string, string> = {\n      '.html': 'text/html',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.json': 'application/json',\n      '.png': 'image/png',\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.gif': 'image/gif',\n      '.svg': 'image/svg+xml',\n      '.ico': 'image/x-icon',\n    };\n\n    const contentType = contentTypes[ext] || 'application/octet-stream';\n\n    // Read and serve file\n    const content = fs.readFileSync(filePath);\n    res.writeHead(200, { 'Content-Type': contentType });\n    res.end(content);\n  }\n\n  private async getAnalyzeData(): Promise<any> {\n    const nodeModulesPath = path.join(this.config.cwd, 'node_modules');\n\n    if (!fs.existsSync(nodeModulesPath)) {\n      return {\n        error: 'No node_modules found',\n        message: 'Run npm install first'\n      };\n    }\n\n    const graph = buildDependencyGraph(nodeModulesPath);\n    const duplicates = detectDuplicates(graph);\n    const depth = analyzeDepth(graph);\n    const deprecated = detectDeprecated(graph, this.config.cwd);\n\n    const sizeResult = calculateSize(nodeModulesPath, {\n      excludeDirs: ['.git', '.DS_Store'],\n    });\n\n    // Convert Map to object for JSON serialization\n    const packagesObj: Record<string, any> = {};\n    graph.packages.forEach((value, key) => {\n      packagesObj[key] = value;\n    });\n\n    // Convert depth distribution Map to object\n    const depthDistributionObj: Record<number, string[]> = {};\n    depth.depthDistribution.forEach((value, key) => {\n      depthDistributionObj[key] = value;\n    });\n\n    return {\n      totalPackages: graph.totalPackages,\n      totalSize: sizeResult.physicalSize,\n      graph: {\n        root: graph.root,\n        packages: packagesObj,\n        totalPackages: graph.totalPackages,\n      },\n      duplicates: {\n        duplicates: duplicates.duplicates,\n        totalWastedBytes: duplicates.totalWastedBytes,\n        totalDuplicatePackages: duplicates.totalDuplicatePackages,\n      },\n      depth: {\n        maxDepth: depth.maxDepth,\n        longestChain: depth.longestChain,\n        depthDistribution: depthDistributionObj,\n        averageDepth: depth.averageDepth,\n      },\n      deprecated: {\n        deprecatedPackages: deprecated.deprecatedPackages,\n        totalDeprecated: deprecated.totalDeprecated,\n      },\n      size: {\n        logical: sizeResult.logicalSize,\n        physical: sizeResult.physicalSize,\n        savings: sizeResult.logicalSize - sizeResult.physicalSize,\n        fileCount: sizeResult.fileCount,\n      },\n    };\n  }\n\n  private async getHealthData(): Promise<any> {\n    const nodeModulesPath = path.join(this.config.cwd, 'node_modules');\n\n    if (!fs.existsSync(nodeModulesPath)) {\n      return {\n        error: 'No node_modules found',\n        message: 'Run npm install first'\n      };\n    }\n\n    const graph = buildDependencyGraph(nodeModulesPath);\n    const duplicates = detectDuplicates(graph);\n    const depth = analyzeDepth(graph);\n    const deprecated = detectDeprecated(graph, this.config.cwd);\n\n    const engine = new HealthEngine();\n    engine.register(depthCheck);\n    engine.register(duplicatesCheck);\n    engine.register(deprecatedCheck);\n    engine.register(sizeCheck);\n\n    const report = await engine.run({\n      cwd: this.config.cwd,\n      graph,\n      duplicates,\n      depth,\n      deprecated,\n    });\n\n    // Calculate individual component scores\n    const duplicateScore = duplicates.totalDuplicatePackages === 0 ? 100 :\n      Math.max(0, 100 - (duplicates.totalDuplicatePackages * 5));\n\n    const deprecationScore = deprecated.totalDeprecated === 0 ? 100 :\n      Math.max(0, 100 - (deprecated.totalDeprecated * 10));\n\n    const depthScore = depth.maxDepth <= 5 ? 100 :\n      Math.max(0, 100 - ((depth.maxDepth - 5) * 5));\n\n    const sizeScore = 85; // Placeholder, can be calculated based on size metrics\n\n    return {\n      score: report.score,\n      grade: this.getGrade(report.score),\n      findings: report.findings,\n      checksPassed: report.checksPassed,\n      checksFailed: report.checksFailed,\n      duplicateScore,\n      deprecationScore,\n      depthScore,\n      sizeScore,\n    };\n  }\n\n  private async getCacheStats(): Promise<any> {\n    const cacheManager = getCacheManager();\n    await cacheManager.initialize();\n    const stats = await cacheManager.getStats();\n\n    return {\n      root: stats.root,\n      totalSize: stats.totalSize,\n      packageCount: stats.packageCount,\n      oldestEntry: stats.oldestEntry,\n      newestEntry: stats.newestEntry,\n    };\n  }\n\n  private getGrade(score: number): string {\n    if (score >= 90) return 'A';\n    if (score >= 80) return 'B';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n}\n","import type { Command, CommandContext } from './index.js';\nimport { registerCommand } from './index.js';\nimport { WebServer } from '../../web/server.js';\nimport { execFileNoThrow } from '../../utils/execFileNoThrow.js';\nimport * as os from 'node:os';\n\nconst serveCommand: Command = {\n  name: 'serve',\n  description: 'Start web UI server for dependency visualization',\n  async run(ctx: CommandContext): Promise<number> {\n    const port = typeof ctx.args.flags['port'] === 'number'\n      ? ctx.args.flags['port']\n      : 3000;\n\n    const noOpen = ctx.args.flags['no-open'] === true;\n    const cwd = process.cwd();\n\n    ctx.output.log(`Starting web server on port ${port}...`);\n\n    const server = new WebServer({ port, cwd });\n\n    try {\n      await server.start();\n\n      const url = `http://localhost:${port}`;\n      ctx.output.log(`Server running at ${url}`);\n      ctx.output.log('Press Ctrl+C to stop');\n\n      // Open browser if not disabled\n      if (!noOpen) {\n        await openBrowser(url);\n      }\n\n      // Keep process alive\n      await new Promise(() => {\n        // This promise never resolves, keeping the server running\n      });\n\n      return 0;\n    } catch (error) {\n      ctx.output.error(`Failed to start server: ${error instanceof Error ? error.message : String(error)}`);\n      return 1;\n    }\n  },\n};\n\nasync function openBrowser(url: string): Promise<void> {\n  const platform = os.platform();\n  let command: string;\n  let args: string[];\n\n  switch (platform) {\n    case 'darwin':\n      command = 'open';\n      args = [url];\n      break;\n    case 'win32':\n      command = 'cmd';\n      args = ['/c', 'start', url];\n      break;\n    default:\n      command = 'xdg-open';\n      args = [url];\n      break;\n  }\n\n  try {\n    await execFileNoThrow(command, args);\n  } catch (error) {\n    console.error('Failed to open browser:', error instanceof Error ? error.message : String(error));\n  }\n}\n\nregisterCommand(serveCommand);\n\nexport default serveCommand;\n","import { parseArgs } from './cli/parser.js';\nimport { createOutput, Output } from './cli/output.js';\nimport { getCommand, commands } from './cli/commands/index.js';\nimport { VERSION } from './index.js';\n\n// Import commands to register them\nimport './cli/commands/install.js';\nimport './cli/commands/analyze.js';\nimport './cli/commands/cache.js';\nimport './cli/commands/doctor.js';\nimport './cli/commands/serve.js';\n\nasync function main(): Promise<number> {\n  const args = parseArgs(process.argv.slice(2));\n  const output = createOutput({ json: args.flags['json'] === true });\n\n  // Handle --version\n  if (args.flags['version'] || args.flags['v']) {\n    output.log(`better v${VERSION}`);\n    return 0;\n  }\n\n  // Handle --help or no command\n  if (args.flags['help'] || args.flags['h'] || !args.command) {\n    printHelp(output);\n    return 0;\n  }\n\n  // Route to command\n  const cmd = getCommand(args.command);\n  if (!cmd) {\n    output.error(`Unknown command: ${args.command}`);\n    output.log(`Run 'better --help' for usage.`);\n    return 1;\n  }\n\n  // Run command (config will be added later)\n  return cmd.run({ args, output, config: {} as any });\n}\n\nfunction printHelp(output: Output): void {\n  output.log(`better v${VERSION} - Production-grade dependency toolkit`);\n  output.log('');\n  output.log('Usage: better <command> [options]');\n  output.log('');\n  output.log('Commands:');\n  for (const [name, cmd] of commands) {\n    output.log(`  ${name.padEnd(12)} ${cmd.description}`);\n  }\n  output.log('');\n  output.log('Global Options:');\n  output.log('  --help, -h       Show this help message');\n  output.log('  --version, -v    Show version');\n  output.log('  --json           Output as JSON');\n  output.log('  --log-level      Set log level (debug, info, warn, error, silent)');\n  output.log('  --config         Path to config file');\n}\n\nmain()\n  .then(code => process.exit(code))\n  .catch(err => {\n    console.error(err);\n    process.exit(1);\n  });\n"],"mappings":"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","names":["spawn","resolve","execFileNoThrow","execFileNoThrow","fs","path","os","execFileNoThrow","platform","fs","path","os","execFileNoThrow","platform","fs","path","os","execFileNoThrow","platform","fs","path","resolve","fs","path","path","result","path","readdirSync","readFileSync","existsSync","join","join","calculateSize","path","readFileSync","calculateSize","join","existsSync","readdirSync","path","fs","path","fs","path","os","path","platform","fs","path","fs","path","path","calculateScore","fs","path","getDirectorySize","fs","path","resolve","calculateSize","cacheManager","os","platform"]}